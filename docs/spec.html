<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>Enterprise Ethereum Enhanced BFT Specification v1</title>

<script
src='https://www.w3.org/Tools/respec/respec-w3c-common'
class='remove'></script>


<style>
table, th, td {
    border: 1px solid black;
    border-collapse: collapse;
}
th, td {
    padding: 5px;
}
</style>

</head>

<body>

<section id='abstract'>

This document, the Enterprise Ethereum Alliance Enhanced BFT Specification, defines
enhancements to the BFT algorithm including liveness and security.

</section>

<section id='sotd'>

*This section describes the status of this document at the time of its
publication. Newer documents might supersede this document.*

This is an editors' draft of the Enterprise Ethereum Alliance Client
Specification version 4. <a href="#sec-changes">Changes made</a> since version 3
of the Specification, released on 13 May 2019, have been reviewed by the
Enterprise Ethereum Alliance (EEA) Technical Specification Working Group (TSWG)
but not the EEA Board.

The TSWG <em>expects</em> at time of writing that this revision of the
Specification will be released in the final quarter of 2019, obsoleting version
3.

Although predicting the future is known to be difficult, as well as ongoing
quality enhancement, future work on this Specification is expected to include
the following aspects:

* Improved <a>privacy</a> management.
* Stronger requirements for interoperability as important components of the
ecosystem become more generally interoperable.
* Adoption of improvements to the <a>Ethereum</a> ecosystem, such as new
technologies or techniques.
* Continued assessment of the needs of different industries to ensure their
requirements for <a>Enterprise Ethereum</a> are taken into account.

Please send any comments to the EEA Technical Steering Committee at
[https://entethalliance.org/contact/](https://entethalliance.org/contact/).

</section>

  <section id="sec-introduction" class="informative">

  <h2>Introduction</h2>

This document, the Enterprise Ethereum Alliance Client Specification, defines
the implementation requirements for <a>Enterprise Ethereum clients</a>,
including the interfaces to external-facing components of
<a>Enterprise Ethereum</a> and how they are intended to be used.

For the purpose of this Specification:

  <ul>
    <li>
An <dfn data-lt="organizations|organizational">organization</dfn> is a logical group
composed of Ethereum <a>accounts</a>, <a>nodes</a>, and organisations.
It typically represents an enterprise, or some identifiable part of an enterprise.
For the purpose of <a>permissioning</a>, an <a>organization</a> roughly corresponds to the Unix concept
of a group.
    </li>
    <li>
<dfn data-lt="Ethereum">Public Ethereum</dfn> (or "Ethereum") is the public blockchain-based distributed
computing platform featuring <a>smart contract</a> (programming) functionality defined by
the Ethereum Yellow Paper [[Ethereum-Yellow-Paper]], EIPs [[EIPs]], and associated specifications.
    </li>
    <li>
<dfn>Enterprise Ethereum</dfn> is the set of enterprise-focused extensions to <a>public Ethereum</a> defined in this Specification.
These extensions provide the ability to perform <a>private transactions</a>,
and enforce <a>permissioning</a>, for Ethereum blockchains that use them. Such blockchains are known as
<dfn>Enterprise Ethereum blockchains</dfn>.
    </li>
    <li>
An <dfn data-lt="enterprise ethereum clients|client|clients|client's">Enterprise Ethereum client</dfn>
(a client) is the software that implements <a>Enterprise Ethereum</a>, and is used to run <a>nodes</a> on an <a>Enterprise Ethereum blockchain</a>.
    </li>
  </ul>

  <aside class="note">
Multiple <a>clients</a> might run on an individual device, or a <a>client</a>
might run on a cloud service.
  </aside>

    <section id="sec-intro-why-client-spec">

    <h3>Why Produce a Client Specification?</h3>

With a growing number of vendors developing <a>Enterprise Ethereum clients</a>, meeting the
requirements outlined in this Client Specification ensures different
<a>clients</a> can communicate with each other and interoperate reliably on a given
<a>Enterprise Ethereum blockchain</a>.

For <a data-lt="Dapp">ÐApp</a> developers, for example, a Client Specification
ensures <a>clients</a> provide a set of identical interfaces so that
<a data-lt="Dapp">ÐApps</a> will work on all conforming <a>clients</a>. This
enables an ecosystem where users can change the software they use to interact
with a running blockchain, instead of being forced to rely on a single vendor to
provide support.

From the beginning, this approach has underpinned the development of
<a>Ethereum</a>, and it meets a key need for blockchain use in
many enterprise settings.

<a>Client</a> diversity also provides a natural mechanism to help verify that
the protocol specification is unambiguous because interoperability errors
revealed in development highlight parts of the protocol that different
engineering teams interpret in different ways.

Finally, standards-based interoperability allows users to leverage the
widespread knowledge of <a>Ethereum</a> in the blockchain development community
to minimize the learning curve for working with <a>Enterprise Ethereum</a>, and
thus reduces risk when deploying an <a>Enterprise Ethereum blockchain</a>.

    </section>

  </section>

  <section id="conformance">

    <section id="sec-experimental-requirements">

    <h3>Experimental Requirements</h3>

This Specification includes requirements and Application Programming Interfaces
(APIs) that are described as <em>experimental</em>. Experimental means that a
requirement or API is in early stages of development and might change as
feedback is incorporated. Implementors are encouraged to implement these
experimental requirements, with the knowledge that requirements in future
versions of the Specification are not guaranteed to be compatible with the
current version. Please send your comments and feedback on the experimental
portions of this Specification to the EEA Technical Steering Committee at
[https://entethalliance.org/contact/](https://entethalliance.org/contact/).

    </section>

    <section id="sec-requirement-categorization">

    <h3>Requirement Categorization</h3>

All requirements in this Specification are categorized as either:

    <ul>
      <li>
<dfn>Protocol requirements</dfn>, denoted by "<b>[P]</b> prefixed to
the requirement ID.
        <p>
Protocol requirements are requirements where the desired properties and
correctness of the system can be jeopardized unless all <a>clients</a> implement
the requirement correctly.
        </p>
      </li>
      <li>
<dfn><a>Client</a> requirements</dfn>, denoted by "<b>[C]</b>" prefixed
to the requirement ID.
        <p>
<a>Client</a> requirements do not impact global system behavior, but if not
implemented correctly in a <a>client</a>, that <a>client</a> might not function
correctly, or to a desirable level, in an <a>Enterprise Ethereum</a> blockchain.
        </p>
      </li>
    </ul>

  <aside class="example" title="Requirement Categorization">
<b><a href="#req-jrpc-050">[C] JRPC-050:</a></b> <a>Enterprise Ethereum clients</a>
MUST implement the [[JSON-RPC-PUB-SUB]] API.

Requirement <b>JRPC-050</b> is a <a>client</a> requirement, which if not
implemented correctly, does not disrupt the correct functioning of an
<a>Enterprise Ethereum</a> blockchain.

<b><a href="#req-smrt-030">[P] SMRT-030:</a></b> <a>Enterprise Ethereum clients</a>
MUST support <a>smart contracts</a> of at least 24,576 bytes in size.

Requirement <b>SMRT-030</b> is a protocol requirement. Running a <a>client</a>
that does not implement this requirement on an <a>Enterprise Ethereum blockchain</a>
risks causing an error in the functioning of the blockchain.
  </aside>

    </section>

  </section>

  <section id="sec-security-considerations" class="informative">

  <h2>Security Considerations</h2>

Security of information systems is a major field of work.
<a>Enterprise Ethereum</a> software development shares with all software
development the need to consider security issues and the obligation to update
implementations in line with new information and techniques to protect its users
and the ecosystem in which it operates.

However, some aspects of <a>Ethereum</a> in general, and
<a>Enterprise Ethereum</a>, in particular, are especially important in an
<a>organizational</a> environment.

<a>Enterprise Ethereum</a> software development shares with all software
development the need to consider security issues and the obligation to update
implementations in line with new information and techniques to protect its users
and the ecosystem in which it operates.

    <section id="sec-attacks-on-ethereum-clients">

    <h3>Attacks on Enterprise Ethereum</h3>

Modeling attacks against a <a>node</a> helps identify and prioritize the
necessary security countermeasures to implement. Some attack categories to
consider include:

- Attacks on unauthenticated [[JSON-RPC]] interfaces through malicious
JavaScript in the browser using DNS rebinding.
- Eclipse attacks (attacks targeting specific <a>nodes</a> in a decentralized
network) that attempt to exhaust <a>client</a> network resources or fool its
node-discovery protocol.
- Targeted exploitation of consensus bugs in <a>EVM</a> implementations.
- Malicious code contributions to open-source repositories.
- All varieties of social engineering attacks.

    </section>

    <section id="sec-positive-security-design-patterns">

    <h3>Positive Security Design Patterns</h3>

Complex interfaces increase security risk by making user error more likely. For
example, entering Ethereum addresses by hand is prone to errors.
Therefore, implementations can reduce the risk by providing user-friendly
interfaces, ensuring users correctly select an opaque identifier using tools
like a contact manager.

<dfn>Gas</dfn> (defined in the [[Ethereum-Yellow-Paper]]) is a virtual pricing
mechanism for <a>transactions</a> and <a>smart contracts</a> that is implemented
by <a>Ethereum</a> to protect against Denial of Service attacks and
resource-consumption attacks by compromised, malfunctioning or malicious <a>nodes</a>.
<a>Enterprise Ethereum</a> provides additional tools to reduce security risks,
such as more granular <a>permissions</a> for actions in a network.

  <p>
<a>Permissioning</a> plays some role in mitigating network-level attacks (like
the 51% attack), but it is important to carefully consider which risks are of
most concern to a <a>client</a> implementation versus those that are better
mitigated by updates to the <a>Ethereum</a> consensus protocol design.
  </p>

    </section>

    <section id="sec-handling-of-senstive-data">

    <h3>Handling of Sensitive Data</h3>

The implications of private data storage are also important to
consider, and motivate several requirements within this Specification.

The long-term persistence of encrypted data on any public platform (such as
<a>Ethereum</a>) exposes it to eventual decryption by brute-force attack,
accelerated by the inevitable periodic advances in cryptanalysis. A future shift
to post-quantum cryptography is a current concern, but it will likely not be the
last advancement in the field. Assuming no encryption scheme endures for
eternity, a degree of protection is required to reasonably exceed the lifetime
of the data's sensitivity.

Besides user-generated data, a <a>client</a> is also responsible for managing
and protecting private keys. Encrypting private keys with a passphrase or other
authentication credential before storage helps protect them from disclosure. It
is also important not to disclose sensitive data when recording events to a log
file.

    </section>

    <section id="sec-security-of-client-implementations">

    <h3>Security of Client Implementations</h3>

There are several specific functionality areas that are more prone to security
issues arising from implementation bugs. The following areas deserve a greater
focus during the design and the security assessment of an
<a>Enterprise Ethereum client</a>:

- Peer-to-peer protocol implementation
- Object deserialization routines
- <a>Ethereum Virtual Machine</a> (<a>EVM</a>) implementation
- Key pair generation.

The peer-to-peer protocol used for communication among <a>nodes</a> in
<a>Ethereum</a> is a <a>client's</a> primary vector for exposure to
untrusted input. In any software, the program logic that handles untrusted
inputs is the primary focus area for implementing secure data handling.

Object serialization and deserialization is commonly part of the underlying
implementation of the P2P protocol, but also a source of complexity that,
historically, is prone to security vulnerabilities across many implementations
and many programming languages. Selecting a deserializer that offers strict
control of data typing can help mitigate the risk.

<a>EVM</a> implementation correctness is an especially important security
consideration for </a>clients</a>. Unless <a data-lt="EVM">EVMs</a> behave
identically for all possibilities of input, there is a serious risk of a
<a>hard fork</a> caused by an input that elicits the differences in behavior
across <a>clients</a>. <a>EVM</a> implementations are also exposed to
denial-of-service attempts by maliciously constructed <a>smart contracts</a>,
and the even more serious risk of an exploitable remote-code-execution
vulnerability.

The <a>Ethereum</a> specification defines many of the technical aspects of
public/private key pair format and cryptographic algorithm choice, but a
</a>client</a> implementation is still responsible for properly generating these
keys using a well-reviewed cryptographic library. Specifically, a <a>client</a>
implementation needs a properly seeded, cryptographically secure, pseudo-random
number generator (PRNG) during the keypair generation step. An insecure PRNG is
not generally apparent by merely observing its outputs, but enables attackers to
break the encryption and reveal users' sensitive data.

    </section>

  </section>

  <section id="sec-enterprise-ethereum-architecture" class="informative">

  <h2>Enterprise Ethereum Architecture</h2>

The following two diagrams show the relationship between
<a>Enterprise Ethereum</a> components that can be part of any
<a>Enterprise Ethereum client</a> implementation. The first is a stack representation of the
architecture showing a library of interfaces, while the second is a more
traditional style architecture diagram showing a representative architecture.

<figure id="fig-stack">
  <img src="./images/ArchitectureStack.svg" alt="Enterprise Ethereum Architecture Stack" style="width:815px;height:645px;">
  <figcaption>Enterprise Ethereum Architecture Stack</figcaption>
</figure>

<figure id="fig-architecture">
  <img src="./images/Architecture.svg" alt="Representative Enterprise Ethereum High-level Architecture" style="width:815px;height:550px;">
  <figcaption>Representative Enterprise Ethereum High-level Architecture</figcaption>
</figure>


The architecture stack for <a>Enterprise Ethereum</a> consists of five layers:

- Application
- Tooling
- Privacy and Scaling
- Core Blockchain
- Network.

These layers are described in the following sections.

  </section>

  <section id="sec-application-layer-main">

  <h2>Application Layer</h2>

The Application layer exists, often fully or partially outside of a
<a>client</a>, where higher-level services are provided. For example,
<a>Ethereum Name Service</a> (ENS), <a>node</a> monitors, blockchain state
visualizations and explorers, self-sovereign and other identity schemes,
<a>wallets</a>, and any other applications of the ecosystem envisaged.

<dfn data-lt="wallet">Wallets</dfn> are software applications used to store an
individual’s credentials (cryptographic private keys), which are associated with
the state of that user’s <a>Ethereum account</a>.

  <p>
<a>Wallets</a> can interface with <a>Enterprise Ethereum</a> using
the Extended RPC API, as shown in <a href="#fig-architecture"></a>. A
<a>wallet</a> can also interface directly with the enclave of a
<a>private transaction manager</a>, or interface with <a>public Ethereum</a>.
  </p>

  <p>
A <dfn>private transaction manager</dfn> is a subsystem of an
<a>Enterprise Ethereum</a> system for implementing <a>privacy</a> and
<a>permissioning</a>.
  </p>

    <section id="sec-dapps-sublayer">

    <h3>ÐApps Sublayer</h3>

Decentralized Applications, or <dfn data-lt="DApp">ÐApps</dfn>, are software
applications running on a decentralized peer-to-peer network, often a
blockchain. A ÐApp might include a user interface running on another
(centralized or decentralized) system. ÐApps run on top of <a>Ethereum</a>.

  <p id="req-dapp-010">
<b>[C] DAPP-010:</b> <a data-lt="Dapp">ÐApps</a> MAY use the extensions to the
<a>Ethereum JSON-RPC API</a> defined in this Specification.
  </p>

Also at the <a data-lt="Dapp">ÐApps</a> sublayer are the blockchain explorers,
the tools to monitor the blockchain, and the business intelligence tools.

    </section>

    <section id="sec-infrastructure-contracts-and-standards-sublayer" class="informative">

    <h3>Infrastructure Contracts and Standards Sublayer</h3>

The Infrastructure Contracts and Standards sublayer shows emerging standards
outside this Specification. The components in this sublayer provide enablers for
the applications built on top of them.

Role Based Access Control (RBAC) defines methods for authentication and
restricting system access to authorized <a>nodes</a> and <a>accounts</a>.
This can be realized through <a>smart contracts</a> such as the
<a>permissioning</a> Contracts in Section
<a href="#sec-example-permissioning-management-smart-contracts"></a>.

Network governance methods control which entities can join the network and hence
assist with safeguarding exchanges.

Token standards provide common interfaces and methods along with best practices.
These include [[ERC-20]], [[ERC-223]], [[ERC-621]], [[ERC-721]], and
[[ERC-827]].

The <dfn data-lt="ENS">Ethereum Name Service</dfn> (ENS) provides a secure and
decentralized mapping from simple, human-readable names to <a>Ethereum</a>
addresses for resources both on and off the blockchain.

    </section>

    <section id="sec-smart-contract-tools-sublayer">

    <h3>Smart Contract Tools Sublayer</h3>

  <p>
<a>Enterprise Ethereum</a> inherits the <a>smart contract</a> tools used by
<a>public Ethereum</a>. These tools include <a>smart contract languages</a> and
associated parsers, compilers, and debuggers, as well as methods used for
<a>formal verification</a> of <a>smart contracts</a>.
  </p>

  <p>
<a>Enterprise Ethereum</a> implementations enable use of these tools and methods
through implementation of the Execution sublayer, as described in Section
<a href="#sec-execution-sublayer"></a>.
  </p>

  <p id="req-smrt-030">
<b>[P] SMRT-030:</b> <a>Enterprise Ethereum clients</a> MUST support <a>smart contracts</a> of at
least 24,576 bytes in size.
  </p>

  <p id="req-smrt-040">
<b>[P] SMRT-040:</b> <a>Enterprise Ethereum clients</a> MUST read and enforce a size limit for
<a>smart contracts</a> from the current <a>network configuration</a> (e.g. the <a>genesis block</a>).
  </p>

  <p id="req-smrt-050">
<b>[P] SMRT-050:</b> If no contract size limit is specified in a
<a>genesis block</a>, subsequent <a>hard fork block</a> or <a>network configuration</a>, <a>Enterprise Ethereum clients</a>
MUST enforce a size limit on <a>smart contracts</a> of 24,576 bytes.
  </p>

The <dfn>genesis block</dfn> is the first block of a blockchain.

A <dfn data-lt="hard forks">hard fork</dfn> is a permanent divergence from the
previous version of a blockchain, and <a>nodes</a> running previous versions
are no longer accepted by the newest version. All <a>nodes</a> that are meant
to work in accordance with the new version of the blockchain must upgrade their
software.

A <dfn>hard fork block</dfn> is the block from which a <a>hard fork</a> occured.

    </section>

  </section>

  <section id="sec-tooling-layer-main">

  <h2>Tooling Layer</h2>

The Tooling layer contains the APIs used to communicate with <a>clients</a>. The
<dfn>Ethereum JSON-RPC API</dfn>, implemented by <a>public Ethereum</a>, is the
primary API to submit <a>transactions</a> for execution, deploy <a>smart contracts</a>,
and to allow <a data-lt="Dapp">ÐApps</a> and <a>wallets</a> to interact with the
platform. The [[JSON-RPC]] remote procedure call protocol and format is used for
the JSON-RPC API implementation. Other APIs are allowed, including those
intended for inter-blockchain operations and to call external services, such as
trusted <a>oracles</a>.

<dfn data-lt="integration library|libraries">Integration libraries</dfn>, such
as [[web3j]], [[web3.js]], and [[Nethereum]], are software libraries used to
implement APIs with different language bindings (like the <a>Ethereum JSON-RPC API</a>)
for interacting with <a>Ethereum</a> <a>nodes</a>.

<a>Public Ethereum</a> <a>nodes</a> can choose to offer local handling of
<a>user</a> credentials, such as key management systems and <a>wallets</a>. Such
facilities might also be implemented outside the scope of a <a>client</a>.

<a>Enterprise Ethereum</a> implementations can restrict operations based on
<a>permissioning</a> and authentication schemes.

  <p>
The Tooling layer also provides support for the compilation, and possibly
<a>formal verification</a> of, <a>smart contracts</a> through the use of parsers
and compilers for one or more <a>smart contract languages</a>.

  <p>
<dfn data-lt="smart contract language|language|languages">Smart contract languages</dfn>
are the programming languages such as [[Solidity]] and [[LLL]] used to create
<a>smart contracts</a>. For each language tools can perform tasks such as compiling to
<a>EVM</a> bytecode, static security checking, or <a>Formal verification</a>.
  </p>

  <p>
<dfn>Formal verification</dfn> is the mathematical verification of the logical
correctness of a <a>smart contract</a> designed to run in the <a>EVM</a>.
  </p>

    <section id="sec-permissions-and-credentials-sublayer">

    <h3>Permissions and Credentials Sublayer</h3>

  <p>
<dfn data-lt="permissions">Permissioning</dfn> is the property of a system that
ensures operations are executed by and accessible to designated parties.
For <a>Enterprise Ethereum</a>, <a>permissioning</a> refers to the ability of a
<a>node</a> to join an <a>Enterprise Ethereum blockchain</a>, and the
ability of individual <a>accounts</a> or <a>nodes</a> to perform specific
functions. For example, an <a>Enterprise Ethereum blockchain</a> might only allow certain
<a>nodes</a> to act as validators, and only certain <a>accounts</a> to
instantiate <a>smart contracts</a>.
  </p>

  <p>
<a>Enterprise Ethereum</a> provides a
<a data-lt="permissioning">permissioned</a> implementation of <a>Ethereum</a>
supporting peer <a>node</a> connectivity <a>permissioning</a>, <a>account</a>
<a>permissioning</a>, and <a>transaction</a> type <a>permissioning</a>.
  </p>

      <section id="sec-nodes">

      <h4>Nodes</h4>

  A <dfn data-lt="nodes">node</dfn> is an instance of an
  <a>Enterprise Ethereum client</a> running on an <a>Enterprise Ethereum blockchain</a>.

  <p id="req-node-010">
<b>[C] NODE-010:</b> <a>Enterprise Ethereum</a> implementations MUST provide the
ability to specify at startup a list of static peer <a>nodes</a> to establish
peer-to-peer connections with.
  </p>

  <p id="req-node-020">
<b>[C] NODE-020:</b> <a>Enterprise Ethereum clients</a> MUST provide the ability to enable or
disable peer-to-peer <a>node</a> discovery.
  </p>

  <p id="req-node-030">
<b>[P] NODE-030:</b> <a>Enterprise Ethereum clients</a> MUST provide the ability to specify a
whitelist of the <a>nodes</a> permitted to connect to a <a>node</a>.
  </p>

  <p id="req-node-040">
<b>[P] NODE-040:</b> <a>Enterprise Ethereum clients</a> MAY provide the ability to specify a
blacklist of the <a>nodes</a> not permitted to connect to a <a>node</a>.
  </p>

  <p id="req-node-050">
<b>[P] NODE-050:</b> It MUST be possible to specify the <a>node</a> whitelist
required by <a href="#req-node-030"><b>NODE-030</b></a> through a <a>transaction</a> into a <a>smart contract</a>.
  </p>

  <p id="req-node-060">
<b>[P] NODE-060:</b> It MUST be possible to specify the <a>node</a> blacklist
allowed by <a href="#req-node-040"><b>NODE-040</b></a> (if implemented)
through a <a>transaction</a> into a <a>smart contract</a>.
  </p>

  <p id="req-node-080">
<b>[P] NODE-080:</b> <a>Enterprise Ethereum clients</a> MUST provide the ability to specify
<a>node</a> identities in a way aligned with the concept of <a>groups</a>.
  </p>

  <p id="req-node-090">
<b>[P] NODE-090:</b> <a>Enterprise Ethereum clients</a> MUST document which metadata parameters
(if any) can affect <a>transaction</a> ordering, and what the effects are.
  </p>

      </section>

      <section id="sec-participants">

      <h4>Ethereum Accounts</h4>

For the purpose of this Specification:

  <ul>
    <li>
A <dfn data-lt="users|user's">User</dfn> is a human or an automated process
interacting with an <a>Enterprise Ethereum blockchain</a> using the
<a>Ethereum JSON-RPC API</a>. The identity of a user is represented by an
<a>Ethereum account</a>. Public key cryptography is used to sign <a>transactions</a>
made by the user so the <a>EVM</a> can authenticate the identity of a user sending a
<a>transaction</a>.
    </li>
    <li>
An <dfn data-lt="ethereum accounts|account|accounts">Ethereum account</dfn> is
an established relationship between a <a>user</a> and an <a>Ethereum</a> blockchain.
Having an Ethereum account allows <a>users</a> to interact with a blockchain,
for example to submit <a>transactions</a> or deploy <a>smart contracts</a>.
See also <a>Wallet</a>.
    </li>
    <li>
<dfn data-lt="group">Groups</dfn> are collections of <a>users</a> that have or
are allocated one or more common attributes. For example, common privileges
allowing <a>users</a> to access a specific set of services or functionality.
    </li>
    <li>
<dfn data-lt="role">Roles</dfn> are sets of administrative tasks, each with
associated <a>permissions</a> that apply to <a>users</a> or administrators of a
system.
    </li>
    <li>
  <dfn data-lt="mainnet">Ethereum MainNet</dfn> is the <a>public Ethereum</a>
  blockchain whose <a href="https://chainid.network/"> `chainid` and `network ID`</a>
  are both `1`.
    </li>
  </ul>

  <p id="req-part-010">
<b>[P] PART-010:</b> <a>Enterprise Ethereum clients</a> MUST provide the ability
to specify a whitelist of <a>accounts</a> that are permitted to transact with the blockchain.
  </p>

  <p id="req-part-015">
<b>[P] PART-015:</b> <a>Enterprise Ethereum clients</a> MUST be able to verify that <a>accounts</a>
are present on the whitelist required by <a href="#req-part-010"><b>PART-010:</b></a>
when adding <a>transactions</a> from the <a>account</a> to a block,
and when verifying a received block containing <a>transactions</a> created by that <a>account</a>.
  </p>

  <p id="req-part-020">
<b>[P] PART-020:</b> <a>Enterprise Ethereum clients</a> MAY provide the ability to specify a
blacklist of <a>accounts</a> that are not permitted to transact with the blockchain.
  </p>

  <p id="req-part-025">
<b>[P] PART-025:</b> <a>Enterprise Ethereum clients</a> MUST be able to verify that <a>accounts</a>
are not present on the blacklist allowed by <a href="#req-part-020"><b>PART-020:</b></a> (if implemented)
when adding <a>transactions</a> from the <a>account</a> to a block,
and when verifying a received block containing <a>transactions</a> created by that <a>account</a>.
  </p>

  <p id="req-part-030">
<b>[P] PART-030:</b> It MUST be possible to specify the <a>account</a>
whitelist required by <a href="#req-part-010"><b>PART-010:</b></a>
through a transaction into a <a>smart contract</a>.
  </p>

  <p id="req-part-040">
<b>[P] PART-040:</b> It MUST be possible to specify the <a>account</a>
blacklist allowed by <a href="#req-part-020"><b>PART-020:</b></a> (if implemented)
through a <a>transaction</a> into a <a>smart contract</a>.
  </p>

  <p id="req-part-050">
<b>[P] PART-050:</b> <a>Enterprise Ethereum clients</a> MUST provide a mechanism
to identify <a>organizations</a> that participate in the <a>Enterprise Ethereum blockchain</a>.
  </p>

  <p class="note">
A specific mechanism could be identified in a future version of this specification.
  </p>

  <p id="req-part-055">
<b>[P] PART-055</b> <a>Enterprise Ethereum clients</a> MUST support anonymous <a>accounts</a>.
  </p>

  <p id="req-part-060">
<b>[P] PART-060:</b> <a>Enterprise Ethereum clients</a> MUST provide the ability
to specify <a>accounts</a> in a way aligned with the concepts of <a>groups</a> and <a>roles</a>.
  </p>

  <p id="req-part-070">
<b>[P] PART-070:</b> <a>Enterprise Ethereum clients</a> MUST be able
to authorize the types of <a>transactions</a> an <a>account</a> can submit,
providing separate <a>permissioning</a> for the ability to:
  </p>

    <ul>
      <li>
Deploy <a>smart contracts</a>.
      </li>
      <li>
Call functions that change the state of specified <a>smart contracts</a>.
      </li>
      <li>
Perform a value transfer to a specified <a>account</a>.
      </li>
    </ul>

  <p class="note">
Since deep nesting of structures can introduce unacceptable performance issues,
implementations can limit how many levels of nesting they actually enable. This specification defines
a bare minimum requirement, although in practice the number of levels implementations support is not
constrained to any paticular level, and depends entirely on implementation choices.
  </p>

  <p id="req-perm-075">
<b>[C] PERM-075:</b>
<a>Enterprise Ethereum clients</a> MUST allow <a>organizations</a>
to be nested to a minimum of at least 3 levels
(i.e. an <a>organization</a> containing an <a>organization</a> that contains another <a>organization</a>).  </p>


      </section>

      <section id="sec-additional-permissioning-requirements">

      <h4>Additional Permissioning Requirements</h4>

  <p id="req-perm-020">
<b>[C] PERM-020:</b> <a>Enterprise Ethereum clients</a>  SHOULD provide the ability for
<a>network configuration</a> to be updated at run time without the need to restart.
  </p>

  <p>
<dfn data-lt="configurable">Network Configuration</dfn> refers to the collection of settings
defined for a blockchain, such as which <a>consensus algorithm</a> to use, addresses of permissioning
smart contracts, and so on.
  </p>

  <p id="req-perm-040">
<b>[C] PERM-040:</b> <a>Enterprise Ethereum clients</a>  MAY support local key management
allowing <a>users</a> to secure their private keys.
  </p>

  <p id="req-perm-050">
<b>[C] PERM-050:</b> <a>Enterprise Ethereum clients</a> MAY support secure interaction
with an external key management system for key generation and secure key storage.
  </p>


Implementations could securely interact with a Hardware Security Module (HSM),
which is a physical device to provide strong and secure key generation, key storage,
and cryptographic processing for deployments where strong security is needed.


      </section>

    </section>

    <section id="sec-integration-and-deployment-tools-sublayer" class="informative">

    <h3>Integration and Deployment Tools Sublayer</h3>

      <section id="sec-enterprise-management-systems">

      <h4>Enterprise Management Systems</h4>

Many software systems implemented in <a>organizations</a> today provide the
ability to integrate with enterprise management systems using common APIs,
<a>libraries</a>, and techniques, as shown in <a href="#fig-management"></a>.

<figure id="fig-management">
  <img src="./images/EEAManagementInterfaces.svg" alt="Management Interfaces" style="width:815px;height:256px;">
  <figcaption>Management Interfaces</figcaption>
</figure>

In addition to deployment and configuration capabilities, <a>Enterprise Ethereum clients</a>
can offer possibilities such as software fault reporting, performance management, security management,
integration with other enterprise software, and historical analysis tools.

These are not requirements of this specification, but features that different software can offer
as part of what distinguishes it from other <a>Enterprise Ethereum clients</a>.

      </section>

    </section>

    <section id="sec-client-interfaces-sublayer">

    <h3>Client Interfaces and APIs Sublayer</h3>

As part of the Client Interfaces and APIs sublayer, [[JSON-RPC]] is a stateless,
light-weight remote procedure call (RPC) protocol using [[JSON]] as its data
format. The [[JSON-RPC]] specification defines several data structures and the
rules around their processing.

  <p>
A <a>Ethereum JSON-RPC API</a> is used to communicate between <a data-lt="DApp">ÐApps</a>
and <a>nodes</a>.
  </p>

      <section id="sec-compatibility-core-ethereum-json-rpc">

      <h4>Compatibility with the Core Ethereum JSON-RPC API</h4>

  <p id="req-jrpc-010">
<b>[P] JRPC-010:</b> <a>Enterprise Ethereum clients</a> MUST provide support for the following
methods of the <a>Ethereum JSON-RPC API</a>:
  </p>

- `net_version`
- `net_peerCount`
- `net_listening`
- `eth_protocolVersion`
- `eth_syncing`
- `eth_coinbase`
- `eth_hashrate`
- `eth_gasPrice`
- `eth_accounts`
- `eth_blockNumber`
- `eth_getBalance`
- `eth_getStorageAt`
- `eth_getTransactionCount`
- `eth_getBlockTransactionCountByHash`
- `eth_getBlockTransactionCountByNumber`
- `eth_getCode`
- `eth_sendRawTransaction`
- `eth_call`
- `eth_estimateGas`
- `eth_getBlockByHash`
- `eth_getBlockByNumber`
- `eth_getTransactionByHash`
- `eth_getTransactionByBlockHashAndIndex`
- `eth_getTransactionByBlockNumberAndIndex`
- `eth_getTransactionReceipt`
- `eth_getUncleByBlockHashAndIndex`
- `eth_getUncleByBlockNumberAndIndex`
- `eth_getLogs`.

  <p id="req-jrpc-007">
<b>[P] JRPC-007:</b> <a>Enterprise Ethereum clients</a> SHOULD implement
[[JSON-RPC-API]] methods to be backward compatible with the definitions given in
version 27e37ee of the <a>Ethereum JSON-RPC API</a> reference [[!JSON-RPC-API-v27e37ee]],
unless breaking changes have been made and widely implemented for the health of the ecosystem.
For example, to fix a major security or privacy problem.
  </p>

  <p id="req-jrpc-015">
<b>[C] JRPC-015:</b> <a>Enterprise Ethereum clients</a> MUST provide the capability to accept
and respond to JSON-RPC method calls over a websocket interface.
  </p>

  <p id="req-jrpc-040">
<b>[C] JRPC-040:</b> <a>Enterprise Ethereum clients</a> MUST provide an implementation of the
<code>debug_traceTransaction</code> method [[debug-traceTransaction]] from the
Go Ethereum Management API.
  </p>

  <p id="req-jrpc-050">
<b>[C] JRPC-050:</b> <a>Enterprise Ethereum clients</a> MUST implement the [[!JSON-RPC-PUB-SUB]] API.
  </p>

  <p id="req-jrpc-070">
<b>[P] JRPC-070:</b> <a>Enterprise Ethereum clients</a> implementing additional nonstandard
subscription types for the [[!JSON-RPC-PUB-SUB]] API MUST prefix their
subscription type names with a namespace prefix other than <code>eea_</code>.
  </p>

      </section>

      <section id="sec-extensions-json-rpc">

      <h4>Extensions to the JSON-RPC API</h4>

*This section is experimental.*

  <p id="req-jrpc-080">
<b>[P] JRPC-080:</b> The [[JSON-RPC]] method name prefix <code>eea_</code> MUST
be reserved for future use for RPC methods specific to the EEA.
  </p>

  <p id="req-jrpc-020">
<b>[P] JRPC-020:</b> <a>Enterprise Ethereum clients</a> MUST provide
one of the following sets of extensions to create <a>private transaction</a> types defined in
Section <a href="#sec-private-transactions"></a>:
  </p>

  <ul>
    <li>
<code>eea_sendTransactionAsync</code> and <code>eea_sendTransaction</code>, or
    </li>
    <li>
<code>eea_sendRawTransactionAsync</code> and
<code>eea_sendRawTransaction</code>.
    </li>
  </ul>

  <p id="req-jrpc-030">
<b>[P] JRPC-030:</b>
The <code>eea_sendTransactionAsync</code>, <code>eea_sendTransaction</code>,
<code>eea_sendRawTransactionAsync</code>, and <code>eea_sendRawTransaction</code>
methods MUST respond with a [[JSON-RPC]] error response when an unimplemented
<a>private transaction</a> type is requested.
The error response MUST have the <var>code</var> <code>-50100</code> and the
<var>message</var> <code>Unimplemented private transaction type</code>.
  </p>

**Example response**

<pre>
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -50100,
    "message": "Unimplemented private transaction type"
  }
}
</pre>

        <section id="sec-eea-sendTransactionAsync">

        <h5>eea_sendTransactionAsync</h5>

A call to `eea_sendTransactionAsync` creates a <a>private transaction</a>, signs
it, submits it to the <a>transaction</a> pool, and returns immediately.

Using this method allows sending many <a>transactions</a> without waiting for
recipient confirmation.

  <p class="note">As in the <a>public Ethereum</a> [[JSON-RPC-API]], the two key
datatypes for this call, which are passed hex encoded, are unformatted data byte
arrays (DATA) and quantities (QUANTITY). When encoding unformatted data, encode
as hex, prefix with "0x", and use two hex digits per byte. When encoding
quantities (integers and numbers), encode as hex and prefix with "0x".
  </p>

**Parameters**

The <a>transaction</a> object for this call contains:

- `from` DATA, 20 bytes – The address of the <a>account</a> sending the
<a>transaction</a>.
- `to` DATA, 20 bytes – The address of the <a>account</a> receiving the
<a>transaction</a>.
- `gas` QUANTITY – Optional. The <a>gas</a>, as an integer, provided for the
<a>transaction</a>.
- `gasPrice` QUANTITY – Optional. The <a>gas</a> price, as an integer.
- `value` QUANTITY – Optional. The value, as an integer, sent with this
<a>transaction</a>.
- `data` DATA, 20 bytes – <a>Transaction</a> data (compiled
<a>smart contract</a> code or encoded method data).
- `nonce` QUANTITY – Optional. A nonce value, as an integer. This allows you to
overwrite your own pending <a>transactions</a> that use the same nonce.
- `privateFrom` DATA, 20 bytes – The public key of the sender of this
<a>private transaction</a>.
- `privateFor` DATA – An array of the public keys of the intended recipients of
this <a>private transaction</a>.
- `restriction` STRING – If `restricted`, the <a>transaction</a> is a
<a>restricted private transaction</a>. If `unrestricted`, the <a>transaction</a>
is an <a>unrestricted private transaction</a>. For more information, see Section
<a href="#sec-private-transactions"></a>.
- `callbackUrl` STRING – The URL to post the results of the <a>transaction</a>
to.

**Callback Body**

The callback object for this call contains:

- `txHash` DATA, 32 bytes – The <a>transaction</a> hash (if successful).
- `txIndex` QUANTITY – The index position, as an integer, of the
<a>transaction</a> in the block.
- `blockHash` DATA, 32 Bytes – The hash of the block this <a>transaction</a> was
in.
- `blockNumber` QUANTITY – The number of the block, as an integer, this
<a>transaction</a> was in.
- `from` DATA, 20 Bytes – The public key of the sender of this
<a>private transaction</a>.
- `to` DATA, 20 Bytes – The <a>account</a> address of the receiver. `null` if a
<a>contract</a> creation <a>transaction</a>.
- `cumulativeGasUsed` QUANTITY – The total amount of <a>gas</a> used when this
<a>transaction</a> was executed in the block.
- `gasUsed` QUANTITY – The amount of <a>gas</a> used by this specific
<a>transaction</a>.
- `contractAddress` DATA, 20 Bytes – The <a>contract</a> address created, if a
<a>contract</a> creation <a>transaction</a>, otherwise `null`.
- `logs` Array – An array of log objects generated by this <a>transaction</a>.
- `logsBloom` DATA, 256 Bytes – A bloom filter for light <a>clients</a> to
quickly retrieve related logs.
- `error` STRING – Optional. Includes an error message describing what went
wrong.
- `id` DATA – Optional. The ID of the request corresponding to this
<a>transaction</a>, as provided in the initial [[JSON-RPC]] call.

Also returned is either:

- `root` DATA, 32 bytes – The post-transaction stateroot (pre-Byzantium).
- `status` QUANTITY – The return status, either 1 (success) or 0 (failure).

**Request Format**

```js
curl -X POST --data
'{"jsonrpc":"2.0","method":"eea_sendTransactionAsync","params":[{
"from": "0xb60e8dd61c5d32be8058bb8eb970870f07233155",
"to": "0xd46e8dd67c5d32be8058bb8eb970870f072445675",
"gas": "0x76c0",
"gasPrice": "0x9184e72a000",
"value": "0x9184e72a",
"data":"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675",
"privateFrom": "0xb60e8dd61c5d32be8058bb8eb970870f07233155",
"privateFor": "0xd46e8dd67c5d32be8058bb8eb970870f072445675",
"callbackUrl": "http://myserver/id=1",
"restriction": "restricted"}],
"id":1}'
```

**Response Format**

```js
{
"id":1,
"jsonrpc": "2.0"
}
```

**Callback Format**

```js
{
"txHash":
"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331"
"txIndex":  "0x1", // 1
"blockNumber": "0xb", // 11
"blockHash": "0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1d1055b",
"cumulativeGasUsed": "0x33bc", // 13244
"gasUsed": "0x4dc", // 1244
"contractAddress": "0xb60e8dd61c5d32be8058bb8eb970870f07233155", // or null, if none was created
"logs": "[{
    // logs as returned by getFilterLogs, etc.
}, ...]",
"logsBloom": "0x00...0", // 256 byte bloom filter
"status": "0x1"
}
```

        </section>

        <section id="sec-eea-sendTransaction">

        <h5>eea_sendTransaction</h5>

Creates a <a>private transaction</a>, signs it, generates the <a>transaction</a>
hash and submits it to the <a>transaction</a> pool, and returns the
<a>transaction</a> hash.

  <p class="note">
As in the <a>public Ethereum</a> [[JSON-RPC-API]], the two key datatypes for
this call, which are passed hex encoded, are unformatted data byte arrays (DATA)
and quantities (QUANTITY). When encoding unformatted data, encode as hex, prefix
with "0x", and use two hex digits per byte. When encoding quantities (integers
and numbers), encode as hex and prefix with "0x".
  </p>

**Parameters**

The <a>transaction</a> object containing:

- `from` DATA, 20 bytes – The address of the <a>account</a> sending the
<a>transaction</a>.
- `to` DATA, 20 bytes – Optional when creating a new <a>contract</a>. The
address of the <a>account</a> receiving the <a>transaction</a>.
- `gas` QUANTITY – Optional. The <a>gas</a>, as an integer, provided for the
<a>transaction</a>.
- `gasPrice` QUANTITY – Optional. The <a>gas</a> price, as an integer.
- `value` QUANTITY – Optional. The value, as an integer, sent with this
<a>transaction</a>.
- `data` DATA, 20 bytes – <a>Transaction</a> data (compiled
<a>smart contract</a> code or encoded method data).
- `nonce` QUANTITY – Optional. A nonce value, as an integer. This allows you to
overwrite your own pending <a>transactions</a> that use the same nonce.
- `privateFrom` DATA, 20 bytes – The public key of the sender of this
<a>private transaction</a>.
- `privateFor` DATA – An array of the public keys of the intended recipients of
this <a>private transaction</a>.
- `restriction` STRING – If `restricted`, the <a>transaction</a> is a
<a>restricted private transaction</a>. If `unrestricted`, the <a>transaction</a>
is an <a>unrestricted private transaction</a>. For more information, see Section
<a href="#sec-private-transactions"></a>.

**Returns**

DATA, 32 Bytes – The <a>transaction</a> hash, or the zero hash if the
<a>transaction</a> is not yet available.

If creating a <a>contract</a>, use `eth_getTransactionReceipt` to retrieve the
<a>contract</a> address after the <a>transaction</a> is <a>finalized</a>.

**Request Format**

```js
curl -X POST --data
'{"jsonrpc":"2.0","method":"eea_sendTransaction","params": [{
"from": "0xb60e8dd61c5d32be8058bb8eb970870f07233155",
"to": "0xd46e8dd67c5d32be8058bb8eb970870f072445675",
"gas": "0x76c0",
"gasPrice": "0x9184e72a000",
"value": "0x9184e72a",
"data":
"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675",
"privateFrom": "0xb60e8dd61c5d32be8058bb8eb970870f07233155",
"privateFor": "0xd46e8dd67c5d32be8058bb8eb970870f072445675",
"restriction": "restricted"}],
"id":1}'
```

**Response Format**

```js
{
"id":1,
"jsonrpc": "2.0",
"result": "0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331"
}
```

        </section>

        <section id="sec-eea-sendRawTransaction">

        <h5>eea_sendRawTransaction</h5>

Creates a <a>private transaction</a>, which has already been signed, generates
the <a>transaction</a> hash and submits it to the <a>transaction</a> pool, and
returns the <a>transaction</a> hash.

The signed <a>transaction</a> passed as an input parameter is expected to
include the `privateFrom`, `privateFor`, and `restriction` fields.

  <p class="note">As in the <a>public Ethereum</a> [[JSON-RPC-API]], the two key
datatypes for this call,  which are passed hex encoded, are unformatted data
byte arrays (DATA) and quantities (QUANTITY). When encoding unformatted data,
encode as hex, prefix with "0x", and use two hex digits per byte. When encoding
quantities (integers and numbers), encode as hex and prefix with "0x".
  </p>

**Parameters**

The <a>transaction</a> object containing:

- `data` DATA – The signed <a>transaction</a> data.

  ```js
  params: ["0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"]
  ```

**Returns**

DATA, 32 Bytes – The <a>transaction</a> hash, or the zero hash if the
<a>transaction</a> is not yet available.

If creating a <a>contract</a>, use `eth_getTransactionReceipt` to retrieve the
<a>contract</a> address after the <a>transaction</a> is <a>finalized</a>.

**Request Format**

```js
curl -X POST --data
'{"jsonrpc":"2.0","method":"eea_sendRawTransaction","params": [{see above}],
"id":1}'
```

**Response Format**

```js
{
"id":1,
"jsonrpc": "2.0",
"result": "0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331"
}
```

        </section>

        <section id="sec-eea-sendRawTransactionAsync">

        <h5>eea_sendRawTransactionAsync</h5>

A call to `eea_sendRawTransactionAsync` creates a <a>private transaction</a>,
which has already been signed, submits it to the <a>transaction</a> pool, and
returns immediately.

Using this method allows sending many <a>transactions</a> without waiting for
recipient confirmation.

The signed <a>transaction</a> passed as an input parameter is expected to
include the `privateFrom`, `privateFor`, `restriction`, and `callbackUrl`
fields.

  <p class="note">As in the <a>public Ethereum</a> [[JSON-RPC-API]], the two key
datatypes for this call,  which are passed hex encoded, are unformatted data
byte arrays (DATA) and quantities (QUANTITY). When encoding unformatted data,
encode as hex, prefix with "0x", and use two hex digits per byte. When encoding
quantities (integers and numbers), encode as hex and prefix with "0x".
  </p>

**Parameters**

The <a>transaction</a> object containing:

- `data` DATA – The signed <a>transaction</a> data.

  ```js
  params: ["0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"]
  ```

**Callback Body**

The callback object for this call contains:

- `txHash` DATA, 32 bytes – The <a>transaction</a> hash (if successful).
- `txIndex` QUANTITY – The index position, as an integer, of the
<a>transaction</a> in the block.
- `blockHash` DATA, 32 Bytes – The hash of the block this <a>transaction</a> was
in.
- `blockNumber` QUANTITY – The number of the block, as an integer, this
<a>transaction</a> was in.
- `from` DATA, 20 Bytes – The public key of the sender of this
<a>private transaction</a>.
- `to` DATA, 20 Bytes – The address of the <a>account</a> receiving this
<a>transaction</a>. `null` if a <a>contract</a> creation <a>transaction</a>.
- `cumulativeGasUsed` QUANTITY – The total amount of <a>gas</a> used when this
<a>transaction</a> was executed in the block.
- `gasUsed` QUANTITY – The amount of <a>gas</a> used by this specific
<a>transaction</a>.
- `contractAddress` DATA, 20 Bytes – The <a>contract</a> address created, if a
<a>contract</a> creation <a>transaction</a>, otherwise `null`.
- `logs` Array – An array of log objects generated by this <a>transaction</a>.
- `logsBloom` DATA, 256 Bytes – A bloom filter for light <a>clients</a> to
quickly retrieve related logs.
- `error` STRING – Optional. Includes an error message describing what went
wrong.
- `id` DATA – Optional. The ID of the request corresponding to this
<a>transaction</a>, as provided in the initial [[JSON-RPC]] call.

Also returned is either:

- `root` DATA, 32 bytes – The post-transaction stateroot (pre-Byzantium).
- `status` QUANTITY – The return status, either 1 (success) or 0 (failure).

**Request Format**

```js
curl -X POST --data
'{"jsonrpc":"2.0","method":"eea_sendRawTransactionAsync","params": [{see above}],
"id":1}'
```

**Response Format**

```js
{
"id":1,
"jsonrpc": "2.0"
}
```

**Callback Format**

```js
{
"txHash":
"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331"
"txIndex":  "0x1", // 1
"blockNumber": "0xb", // 11
"blockHash": "0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1d1055b",
"cumulativeGasUsed": "0x33bc", // 13244
"gasUsed": "0x4dc", // 1244
"contractAddress": "0xb60e8dd61c5d32be8058bb8eb970870f07233155", // or null, if none was created
"logs": "[{
    // logs as returned by getFilterLogs, etc.
}, ...]",
"logsBloom": "0x00...0", // 256 byte bloom filter
"status": "0x1"
}
```

        </section>



      <section id="sec-permissioning-smart-contracts">

      <h4>Permissioning Smart Contract</h4>

This section presents <a>smart contract</a> interfaces providing the necessary
information for <a>Enterprise Ethereum clients</a> to enforce
<a>permissioning</a> models in an interoperable manner. This includes both
<a>node</a> and <a>account</a> <a>permissioning</a> interfaces.

It is based on a chain deployment architecture where <a>permissioning</a> is
split into two parts:

  <ul>
    <li>
<a>Permissioning</a> enforcement <a>smart contract</a> functions.

<a>Clients</a> call permission-allowed functions within the <a>permissioning</a>
<a>smart contract</a>. These are common functions for all <a>clients</a> on the
<a>Enterprise Ethereum blockchain</a> to use. These functions include:
    <ul>
      <li>
`connectionAllowed`, to determine whether to permit
a connection with another <a>node</a>.
      </li>
      <li>
`transactionAllowed`, to determine whether to accept a
<a>transaction</a> received from a given <a>Ethereum account</a>.
      </li>
    </ul>
A <a>client</a> is not required to be able to update the <a>permissioning</a>
scheme nor have knowledge of its implementation.

Both <a>node</a> and <a>account</a> <a>smart contract</a> interfaces emit a
`permissionsUpdated` event when the underlying rules are changed. <a>Clients</a>
register for these events that signal when to
re-assess any <a>permissions</a> that were granted, and when to re-assess any
<a>permission</a> check results that were cached.

The event contains an `addsRestrictions` Boolean flag. If the flag is `true`,
any previous `connectionAllowed` or `transactionAllowed` call could now result
in a different outcome, potentially making the previously checked
<a>permissions</a> more restrictive. If `addsRestrictions` is `false`, this
indicates that previous `connectionAllowed` or `transactionAllowed` calls that
returned `false` could now return `true` because the <a>permissions</a> are now
less restrictive than when previously checked.
    </li>
    <li>
<a>Permissioning</a> management <a>smart contract</a> functions.

These <a>smart contract</a> functions provide the ability to configure and
manage the <a>permissioning</a> model in use. These include the bulk
of the constructs used to organize <a>permissions</a>, processes to adjust
<a>permissions</a>, administration of the <a>permissioning</a> mechanism, and
enforcing any regulatory requirements.

The definition of these management functions depends on the <a>permissioning</a>
model of the specific <a>Enterprise Ethereum blockchain</a>.
It is outside the scope of this Specification, but
crucial to the operation of the system.

  <p>
<a>Enterprise Ethereum blockchain</a> operators can choose any <a>permissioning</a>
model that suits their needs.
  </p>
    </li>
  </ul>

Implementations of the <a>permissioning</a> <a>smart contract</a> (both
enforcement and management functions) must be provided on the <a>Enterprise Ethereum blockchain</a>
by the blockchain operator. The implementation of <a>permissioning</a> enforcement functions
such as `connectionAllowed` is part of the <a>permissioning</a> management
<a>smart contract</a>.

  <p>
When a management function is called that updates the <a>permissioning</a>
model, the <a>node</a> or <a>account</a> <a>smart contract</a> interfaces emit
a `permissionsUpdated` event based on the <a>permissions</a> change.
  </p>


        <section id="sec-node-permissioning">

        <h5>Node Permissioning</h5>

  <p>
<a>Node</a> <a>permissioning</a> restricts the peer connections that can be
established with other <a>nodes</a> in the <a>Enterprise Ethereum blockchain</a>.
This helps to prevent interference and abuse by external parties and can establish
a trusted whitelist of <a>nodes</a>.
  </p>

  <p id="req-perm-200">
<b>[P] PERM-200:</b>
<a>Enterprise Ethereum clients</a> MUST call the <code>connectionAllowed</code>
function, as specified in Section <a href="#sec-node-permissioning-functions"></a>,
to determine whether a connection with another <a>node</a> is permitted,
and any restrictions to be placed on that connection.
  </p>

The <code>connectionAllowed</code> function returns a <code>bytes32</code> type,
which is interpreted as a bitmask with each bit representing a specific
permission for the connection.

  <p id="req-perm-210">
<b>[P] PERM-210:</b> When checking the response to
<code>connectionAllowed</code>, if any unknown permissioning bits are found to
be zero, <a>Enterprise Ethereum clients</a> MUST reject the connection.
  </p>

  <p id="req-perm-220">
<b>[P] PERM-220:</b> On receipt of a <code>NodePermissionsUpdated</code>
event containing an 'addsRestrictions' property with value 'true',
<a>Enterprise Ethereum clients</a> MUST close any network connections
that are no longer permitted, and impose newly added restrictions on any
network connections that have had restrictions added.
  </p>

  <p id="req-perm-230">
<a href="#req-perm-230">
<b>[P] PERM-230:</b> On receipt of a <code>NodePermissionsUpdated</code>
event containing an 'addsRestrictions' property with value 'false',
<a>Enterprise Ethereum clients</a> MUST conduct a check on whether existing network connections have had their restrictions lifted and allow future actions that are now permitted.
  </p>

          <section id="sec-node-permissioning-functions">

	  <h6>Node Permissioning Functions</h6>

Support must be provided for both IPv4 and IPv6 protocol versions, so the node
connection rules must account for this. IPv6 addresses are represented using their
logical byte value with big endian byte ordering. IPv4 addresses are specified
in the IPv4 reserved space within the IPv6 address space which is found at
'0000:0000:0000:0000:0000:ffff:' and can be be assembled by taking the logical byte value of
the IPv4 address with big endain byte ordering and prefixing it with 80 bits of 0's
followed by 16 bits of 1's.


  <pre class="solidity">
Interface
[
  {
    "name": "connectionAllowed",
    "stateMutability": "view",
    "type": "function",
    "inputs": [
      {
        "name": "sourceEnodeHigh",
        "type": "bytes32"
      },
      {
        "name": "sourceEnodeLow",
        "type": "bytes32"
      },
      {
        "name": "sourceIp",
        "type": "bytes16"
      },
      {
        "name": "sourcePort",
        "type": "uint16"
      },
      {
        "name": "destinationEnodeHigh",
        "type": "bytes32"
      },
      {
        "name": "destinationEnodeLow",
        "type": "bytes32"
      },
      {
        "name": "destinationIp",
        "type": "bytes16"
      },
      {
        "name": "destinationPort",
        "type": "uint16"
      },
    ],
    "outputs": [
      {
        "name": "res",
        "type": "bytes32"
      }
    ]
  },
  {
    "type": "event",
    "name": "NodePermissionsUpdated",
    "inputs": [
      {
        "name": "addsRestrictions",
        "type": "bool",
        "indexed": false
      }
    ]
  }
]
  </pre>

**Arguments**

- `sourceEnodeHigh`: The high (first) 32 bytes of the enode address of the
<a>node</a> initializing the connection.
- `sourceEnodeLow`: The low (last) 32 bytes of the enode address of the
<a>node</a> initiating the connection.
- `sourceIp`: The IP address of the <a>node</a> initiating the
connection. If the address is IPv4 it should be prefixed by 80 bits of zeros and
16 bits of ones, bitmasking it such that it fits the IPv4 reserved space in IPv6.
For example, `::ffff:127.0.0.1`.
- `sourceEnodePort`: The peer-to-peer listening port of the <a>node</a>
initiating the connection.
- `destinationEnodeHigh`: The high (first) 32 bytes of the enode address of the
<a>node</a> receiving the connection.
- `destinationEnodeLow`: The low (last) 32 bytes of the enode address of the
<a>node</a> receiving the connection.
- `destinationIp`: The IP address of the <a>node</a> receiving the
connection. If the address is IPv4 it should be prefixed by 80 bits of zeros and
16 bits of ones, bitmasking it such that it fits the IPv4 reserved space in IPv6.
For example, `::ffff:127.0.0.1`.
- `destinationEnodePort`: The peer-to-peer listening port of the <a>node</a>
receiving the connection.
- `res`: A bitmask of the permissions granted for this connection.
- `addsRestrictions`: If the rules change that caused the
`NodePermissionsUpdated` event to be emitted involves further restricting
existing permissions, this will be `true`. Otherwise if `false`, the change
event represents the permission set becoming more permissive.

        </section>

          <section id="sec-node-permissions">

          <h6>Node Permissions</h6>

While the core premise of node permissioning is whether a connection is allowed
to occur, there are additional restrictions that can be imposed on a connection
between two nodes based on the permitted behaviour of the nodes.

The various permissions that can be granted to a connection are represented by
bits being set in the bitmask response from `connectionAllowed`. Where bits are
unset, the client should restrict the behaviour of the remote node according to
the unset bits.

The remaining bits in the response are to be set to one. If any of the remaining
bits are found to be zero, then it should be assumed that an unknown permission
restriction was placed on the connection and the connection should be denied.
These unknown zeros are likely to be representing permissions defined in future
versions of this specification. Where they cannot be interpreted by a client the
connection is rejected.

  <b>Connection permitted</b>

  Permission Bit Index: 0

  The connection is allowed to be established.

          </section>

          <section id="sec-node-client-implementation">

          <h6>Client Implementation</h6>

A <a>client</a> connecting to a chain that maintains a <a>smart contract</a>
exposing the <a>node</a> <a>permissioning</a> interface can expect to be
supplied the address of the <a>contract</a>. When a peer connection request is
received, or a new connection request initiated, the <a>smart contract</a> is
queried to assess whether the connection is permitted. If permitted, the
connection is established and when the <a>node</a> is queried for peer
discovery, this connection can be advertised as an available peer. If not
permitted, the connection is either refused or not attempted, and the peer
excluded from any responses to peer discovery requests.

During <a>client</a> startup and initialization it is expected that the
<a>client</a> will be provided a bootnode and initially have a global state
that is out of sync. Until the <a>client</a> reaches a trustworthy head it
is unable to reach a current version of the <a>node</a> permissioning
that correctly represents the current blockchain's state.

          </section>

          <section id="sec-chain-initialization">

          <h6>Chain Initialization</h6>

At the genesis block the <a>node</a> <a>permissioning</a> <a>contract</a> should
be included in block 0 and configured such that the initial <a>nodes</a> are
able to establish connections to each other.

          </section>

        </section>

        <section id="sec-account-permissioning">

        <h5>Account Permissioning</h5>

Account permissioning controls which accounts are able to send
<a>transactions</a> and the type of <a>transactions</a> permitted.

  <p id="req-perm-240">
<b>[P] PERM-240:</b> When validating or mining a block, <a>Enterprise Ethereum clients</a> MUST
call the <code>transactionAllowed</code> function, as specified in
Section <a href="#sec-account-permissioning-function"></a>, with worldstate as
at the block's parent, to determine if a <a>transaction</a> is permitted in a block.
  </p>

          <section id="sec-account-permissioning-function">

          <h6>Account Permissioning Smart Contract Interface Function</h6>

  <pre class="solidity">
Interface
[
  {
    "name": "transactionAllowed",
    "stateMutability": "view",
    "type": "function",
    "inputs": [
      {
        "name": "sender",
        "type": "address"
      },
      {
        "name": "target",
        "type": "address"
      },
      {
        "name": "value",
        "type": "uint256"
      },
      {
        "name": "gasPrice",
        "type": "uint256"
      },
      {
        "name": "gasLimit",
        "type": "uint256"
      },
      {
        "name": "payload",
        "type": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "res",
        "type": "bool"
      }
    ]
  },
  {
    "type": "event",
    "name": "AccountPermissionsUpdated",
    "inputs": [
      {
        "name": "addsRestrictions",
        "type": "bool",
        "indexed": false
      }
    ]
  }
]
  </pre>

**Arguments**

- `sender`: The address of the <a>account</a> that created this
<a>transaction</a>.
- `target`: The address of the <a>account</a> or <a>contract</a> that this
<a>transaction</a> is directed at. In case of a creation <a>contract</a> where
there is no target, this should be zero filled to represent the `null` address.
- `value`: The eth value being transferred in this <a>transaction</a>.
- `gasPrice`: The <a>gas</a> price included in this <a>transaction</a>
- `gasLimit`: The <a>gas</a> limit in this <a>transaction</a>.
- `payload`: The payload in this <a>transaction</a>. Either empty if a simple
value <a>transaction</a>, the calling payload if executing a <a>contract</a>, or
the <a>EVM</a> code to be deployed for a <a>contract</a> creation.
- `res`: A Boolean representing whether the <a>transaction</a> should be allowed
and considered valid.
- `addsRestrictions`: If the rules change that caused the
`AccountPermissionsUpdated` event to be emitted involves further restricting
existing permissions this will be `true`. Otherwise if `false` the change event
represents the permission set becoming more permissive.

          </section>

          <section id="sec-account-client-implementation">

          <h6>Client Implementation</h6>

A <a>client</a> connecting to a chain that maintains a <a>smart contract</a>
exposing the account permissioning interface can expect to be supplied the
address of the <a>contract</a>.

When mining new blocks the <a>node</a> checks the validity of
<a>transactions</a> using the appropriate <a>smart contract</a> with the state
at the block's parent. If not permitted, the <a>transaction</a> is discarded. If
permitted, the <a>transaction</a> is included in the new block and the block
dispatched to other nodes.

When receiving a block the <a>node</a> checks each included <a>transaction</a>
using the <a>smart contract</a> with the state at the block's parent. If any
<a>transactions</a> in the new block are not permitted, the block is
considered invalid and discarded. If all <a>transactions</a> are permitted, the
block passes the <a>permissioning</a> validation check and is then subject to
any other validity assessments the <a>client</a> might usually perform.

Depending on the use case of a <a>client</a>, the implementation might also
check validity of <a>transactions</a> upon being lodged through RPC methods or
received through peer-to-peer communication. For such validation, it is expected
that the <a>contracts</a> are used with the state represented at the current
head.

Reading of a <a>contract</a> is an unrestricted operation.

          </section>

          <section id="sec-account-contract-implementation">

          <h6>Contract Implementation</h6>

When a <a>transaction</a> is checked by the <a>contract</a> it can be assessed by
any of the fields provided to restrict operations, such as transferring value
between <a>accounts</a>, rate limiting spend or receipt of value, restricting
the ability to execute code at an address, limiting <a>gas</a> expenditure or
enforcing a minimum expenditure, or restricting the scope of a created
<a>contract</a>.

When checking the execution of code at an address, it can be useful to be aware
of the `EXTCODEHASH` <a>EVM</a> operation, which allows for checking whether
there is code present to be executed at the address that received the request.


For restricting the scope of created contracts it might be necessary to do
static code analysis of the <a>EVM</a> bytecode payload for properties that are
not allowed. For example, restricting creation of <a>contracts</a> that employ
the create contract opcode.

          </section>

          <section id="sec-account-chain-initialization">

          <h6>Chain Initialization</h6>

At the genesis block the <a>account</a> <a>permissioning</a>
<a>smart contract</a> function should be included in block 0 and configured such
that initial <a>accounts</a> can perform required value <a>transactions</a>, a
predetermined set of <a>accounts</a> can invoke the <a>contracts</a> defined in
the genesis file, and if desired, a predetermined set of <a>accounts</a> can
create new <a>contracts</a>.

          </section>

        </section>

<section id="sec-example-permissioning-management-smart-contracts" class="informative">

  <h5>Permissioning management: examples</h5>

The <a>smart contracts</a> that allow <a>Enterprise Ethereum clients</a> to apply
<a>permissioning</a> require a management system behind them. This section provides
some examples of how such a system might work, but each <a>Enterprise Ethereum blockchain</a>
is free to implement whatever system is suitable, as long as it includes the required functions
for clients to query.


<aside id="sec-example-permissioning-simple" class="example"
       title="Permissioning contracts: simple authorization whitelist">

This section presents a basic permissioning smart contract that maintains a
whitelist of enodes allowed to participate in the <a>Enterprise Ethereum blockchain</a>,
and a list of administrative accounts that can alter that whitelist.

In this model administrators are allowed to add and remove administrators, and
add and remove <a>nodes</a>. Clients can check whether a given connection is permitted
via the `connectionAllowed` function which checks that the enode addresses of
both nodes involved in the connection are in the whitelist. When a permission
rule update occurs a `NodePermissionsUpdated` event is emitted indicating that a
rules change has occurred, and whether the rule change makes the
<a>Enterprise Ethereum blockchain</a> more permissive or adds new restrictions.

When deploying the contract it is initialised with the account deploying it
as the first administrator. This account can then add additional
administrators and add <a>nodes</a> to the whitelist.

This contract serves as an example only. As written it has shortcomings that
should be considered in any production environment. Some potentially desirable
features which are not included in this example are:

<ul>
  <li>Protection against all administors being removed</li>
  <li>A list of current administrators</li>
  <li>The current whitelisted enodes</li>
  <li>Protection against a single administrator taking over the permissioning system</li>
  <li>A way to upgrade the contract logic</li>
  <li>Grouping or organization of whitelist members</li>
</ul>

<pre class="solidity">
pragma solidity >=0.4.0 <0.6.0;
contract SimplePermissioning {
    // Struct representing an enode
    struct Enode {
        bytes32 enodeHigh;
        bytes32 enodeLow;
        bytes16 enodeHost;
        uint16 enodePort;
    }

    // Event emitted when a rules change occurs
    event NodePermissionsUpdated(
        bool addsRestrictions
    );

    // List of nodes permitted to participate in the network
    mapping(bytes => Enode) private whitelist;

    // List of accounts allowed to modify the network
    mapping(address => bool) private adminList;

    constructor() public {
        // set the contract creator as the first admin
        adminList[msg.sender] = true;
    }

    // Guard modifier for functions that should only be invokable by admins
    modifier onlyAdmin() {
        require(adminList[msg.sender] == true, "Caller must be in the admin list");
        _;
    }

    // Add an admin to the contract
    function addAdmin(address newAdmin) public onlyAdmin {
        adminList[newAdmin] = true;
    }

    // Remove an admin from the contract
    function removeAdmin(address oldAdmin) public onlyAdmin {
        adminList[oldAdmin] = false;
    }

    // Check if a connection between two nodes should be permitted
    function connectionAllowed(
        bytes32 sourceEnodeHigh,
        bytes32 sourceEnodeLow,
        bytes16 sourceEnodeIp,
        uint16 sourceEnodePort,
        bytes32 destinationEnodeHigh,
        bytes32 destinationEnodeLow,
        bytes16 destinationEnodeIp,
        uint16 destinationEnodePort
    ) public view returns (bytes32) {
        // Check that both are in the whitelist
        if (
            enodeAllowed(sourceEnodeHigh, sourceEnodeLow, sourceEnodeIp, sourceEnodePort)
            && enodeAllowed(destinationEnodeHigh, destinationEnodeLow, destinationEnodeIp, destinationEnodePort)
        ) {
            // If both are then indicate permitted by returning the first bit as set
            return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
        } else {
            // If one or neither are permitted then indicate not permitted by unsetting the first bit
            return 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
        }
    }

    // Check if a specified enode is in the whitelist
    function enodeAllowed(
        bytes32 sourceEnodeHigh,
        bytes32 sourceEnodeLow,
        bytes16 sourceEnodeIp,
        uint16 sourceEnodePort
    ) public view returns (bool){
        bytes memory key = computeKey(sourceEnodeHigh, sourceEnodeLow, sourceEnodeIp, sourceEnodePort);
        Enode storage whitelistSource = whitelist[key];
        if (whitelistSource.enodeHost > 0) {
            return true;
        }
    }

    // Add a specified enode to the whitelist
    function addEnode(
        bytes32 enodeHigh,
        bytes32 enodeLow,
        bytes16 enodeIp,
        uint16 enodePort
    ) public onlyAdmin {
        Enode memory newEnode = Enode(enodeHigh, enodeLow, enodeIp, enodePort);
        bytes memory key = computeKey(enodeHigh, enodeLow, enodeIp, enodePort);
        whitelist[key] = newEnode;
        // Emit an event indicating a permissioning update occurred that only
        // allows new nodes into the network
        emit NodePermissionsUpdated(false);
    }

    // Remove a specified enode from the whitelist
    function removeEnode(
        bytes32 enodeHigh,
        bytes32 enodeLow,
        bytes16 enodeIp,
        uint16 enodePort
    ) public onlyAdmin {
        bytes memory key = computeKey(enodeHigh, enodeLow, enodeIp, enodePort);
        Enode memory zeros = Enode(bytes32(0), bytes32(0), bytes16(0), 0);
        whitelist[key] = zeros;
        // Emit an event indicating a permissioning update occurred that can
        // cause existing connections to now be disallowed
        emit NodePermissionsUpdated(true);
    }

    // Compute a consistent hashkey for a given enode
    function computeKey(
        bytes32 enodeHigh,
        bytes32 enodeLow,
        bytes16 enodeIp,
        uint16 enodePort
    ) public pure returns (bytes memory) {
        return abi.encode(enodeHigh, enodeLow, enodeIp, enodePort);
    }
}
</pre>
</aside>

<aside id="sec-example-permissioning-bespoke" class="example"
  title="Permissioning contracts: memberGroups and authorizedUsers">

This section presents an example permissioning model with four <a>smart contract</a>
interfaces for management, and methods for enforcement.
These example interfaces are for <a>node</a> <a>permissioning</a>.

A permissioned <a>Enterprise Ethereum blockchain</a> includes <a>smart contracts</a>
that implement the permissioning enforcement interfaces specified in Section
<a href="#sec-permissioning-smart-contracts"></a>, along with whatever management
functions are appropriate for the chosen permissioning model.

The model in this example is based on the concept of a <dfn>network</dfn>,
that consists of a set of <dfn>memberGroups</dfn>, each representing an
enterprise or organization, and each made up of <a>authorizedUsers</a>.

In this model <a>nodes</a> are added to or removed from the <a>node list</a>
of a <a>memberGroup</a>. If a <a>memberGroup</a> joins the <a>network</a>,
the <a>nodes</a> in that <a>memberGroup</a>'s <a>node list</a> are permitted to join.
Conversely, if the <a>memberGroup</a> is removed from the <a>network</a>,
the <a>nodes</a> associated with that <a>memberGroup</a> are disconnected.

As noted, <a>memberGroup</a>s are a collection of <a>authorizedUsers</a>.
An <dfn data-lt="authorizedUsers">authorizedUser</dfn> is represented by one or more
<a>Ethereum accounts</a>. This provides robustness in case a given user loses the keys
to one of their accounts,
as well as reflecting the reality that many users operate more than a single account.

Each <a>authorizedUser</a> has individually specified permissions, to act on
behalf of the <a>memberGroup</a> in administering the <a>Enterprise Ethereum blockchain</a>.
Depending on the specific <a>permissions</a> they have, an <a>authorizedUser</a>
can make changes such as adding a new <a>authorizedUser</a> to a <a>memberGroup</a>,
adding a new <a>node</a> to a <a>memberGroup</a>'s <a>node list</a>, or inviting another
<a>memberGroup</a> to join the <a>Enterprise Ethereum blockchain</a>.

A <dfn>permissioning decider</dfn> function is used to decide whether or not a
<a>memberGroup</a> should be permitted to join the <a>network</a>, when to evict a
<a>memberGroup</a>, and especially whether to change the <a>permissioning decider</a> itself.

This model uses four fundamental <a>smart contract</a> interfaces:

- `AuthorizedUser`
- `MemberGroup`
- `Network`
- `PermissioningDecider`.


<section id="sec-example-permissioning-bespoke-authorizedUser">

        <h5><code>AuthorizedUser</code></h5>

The `authorizedUser` <a>smart contract</a> contains <a>authorizedUsers</a>, initialized
with a name and an identifier, like an email address. Additional information
such as alternative contact information or PGP public keys, could also be
included by implementations of `authorizedUser`.

  <pre class="solidity">
pragma solidity ^0.5.1;
interface AuthorizedUser {

    // Metadata

    // Retrieve the user's name.
    function getName() external view returns (string memory);

    // Retrieve the user's identifier.
    function getId() external view returns (string memory);

    // Authorization mutation.

    // Add an Ethereum account address for an authorizedUser. Multiple addresses
    // can be added.
    function addAddress(address _owner) external;

    // Remove an Ethereum account address from an authorizedUser.
    function removeAddress(address _owner) external;

    // Authorization queries.

    // Check if the authorizedUser owns a specific Ethereum account address.
    function owns(address _owner) external view returns (bool);

    // Network of trust (reputation) mutators.

    // Check if the authorizedUser vouches for another (child) authorizedUser.
    function hasEndorsed(AuthorizedUser _child) external view returns (bool);

    // Vouch for another authorizedUser.
    function endorse(AuthorizedUser _child) external;

    // Stop vouching for an authorizedUser
    function unendorse(AuthorizedUser _child) external;

    // Network of trust backlinks. These should be called by `endorse` and
    // `unendorse` implementations respectively, to provide pointers about where
    // to look for endorsements.

    // Set the (parent) authorizedUser as vouching for the authorizedUser.
    function recordEndorsement(AuthorizedUser _parent) external;

    // Set the (parent) authorizedUser to no longer vouch for the authorizedUser.
    function eraseEndorsement(AuthorizedUser _parent) external;
}
  </pre>

A user is responsible for deciding to endorse someone as an authorizedUser.
Some examples of how Alice might decide to endorse Bob

- alice@a.net sends an email to bob@a.net, asking to confirm Bob's
<a>authorizedUser</a> address.
- alice@a.net sends an email to bob@b.com,
asking Bob to join a video call to assert his ownership of a given <a>Ethereum account</a>.
- Alice walks over to Bob's desk and asks for his <a>Ethereum account</a> address.

  <p class="note">
Any caller can add any address as a parent of a <a>authorizedUser</a>. To
authenticate an <a>authorizedUser</a>, the contract follows the parent links
and checks that the corresponding child link is present.
  </p>

        </section>

        <section id="sec-example-permissioning-bespoke-memberGroup">

        <h5><code>MemberGroup</code></h5>

The `MemberGroup` represents a group of
<a>authorizedUsers</a> and their <a>permissions</a>.

  <pre class="solidity">
pragma solidity ^0.5.1;
import "./AuthorizedUser.sol";
interface MemberGroup {

    // Metadata

    // Retrieve the memberGroup name.
    function getName() external view returns (string memory);

    // Retrieve the permissions for an authorizedUser.
    function permission(AuthorizedUser) external view returns (uint);

    // Retrieve the number of authorizedUsers in the memberGroup.
    function memberCount() external view returns (uint);

    // Retrieve an authorizedUser, specified by index idx, from the memberGroup.
    function getMember(uint idx) external view returns (AuthorizedUser);

    // Managing membership of the group

    // Add an authorizedUser to the memberGroup. Requester must have
    // `CAN_ADD_USER` permission.
    function addUser(AuthorizedUser requester, AuthorizedUser object,
                                   uint _permission) external;

    // Remove a authorizedUsers from the memberGroup. Requester must have
    // `CAN_REMOVE_USER` permission.
    function removeUser(AuthorizedUser requester,
                                   AuthorizedUser object) external;

    // Events

    // Emitted when an authorizedUser is added to a memberGroup.
    event MemberAdded(AuthorizedUser _user, uint _permission);

    // Emitted when an authorizedUser is removed from a memberGroup.
    event MemberRemoved(AuthorizedUser _user, uint _permission);
}
  </pre>

An <a>authorizedUser</a> is given <a>permissions</a> as follows:

- The <a>authorizedUser</a> who calls the `addUser` funtion - the "requestor" -
proposes a set of <a>permissions</a> as the `_permission` parameter.
- The contract does a bitwise AND of the requester's own permissions with the request.
- The result is recorded as the <a>permission</a> for the newly added authorizedUser.

A partial definition of permissions could be as follows:

  <pre class="solidity">
pragma solidity ^0.5.1;
contract Permissions {

    // Permission to add or remove an authorizedUser.
    uint constant public CAN_ADD_USER = 0x1;
    uint constant public CAN_REMOVE_USER = 0x2;

    // Permission to change the node list of a memberGroup.
    uint constant public CAN_ADD_NODE = 0x4;
    uint constant public CAN_REMOVE_NODE = 0x8;

    // Permission to vote for other memberGroups to join or leave the network.
    uint constant public CAN_INVITE_MEMBERGROUP = 0x10;
    uint constant public CAN_UNINVITE_MEMBERGROUP = 0x20;

    // Permission to vote for a new <a>permission decider</a>
    uint constant public CAN_PROPOSE_DECIDER = 0x100;

    uint constant public ADMIN = 0x1ff;

    function meets(uint have, uint needed) public pure returns (bool) {
        return have & needed == needed;
    }
}
  </pre>

        </section>

        <section id="sec-example-permissioning-bespoke-network">

        <h5><code>Network</code></h5>

As described above, <a>network</a>s are a collection of <a>memberGroup</a>s.
Each <a>memberGroup</a> manages a <dfn>node list</dfn>: a list of [[enode]] URLs,
corresponding to the <a>nodes</a> allowed to connect to the <a>Enterprise Ethereum blockchain</a>
that are controlled by the <a>memberGroup</a>. Any <a>authorizedUser</a> that is part of the
<a>memberGroup</a> and has the `CAN_ADD_NODE` <a>permission</a> can add to the <a>node list</a>
for that <a>memberGroup</a>.

To add a <a>memberGroup</a> to or remove them from the <a>Enterprise Ethereum blockchain</a>,
every <a>memberGroup</a> that is already a member can vote to `invite` or `uninvite` them.
The <a>permissioning decider</a> for the <a>network</a> determines whether to update
the <a>network</a> members, given the current set of requests.

A <a>memberGroup</a> can have `WRITE` or `READ` <a>permissions</a>, set as part of adding it
to the <a>network</a>. A <a>node</a>  belonging to a <a>memberGroup</a>
that has `WRITE` permission can submit a transaction,
but transactions from a <a>node</a> in a <a>memberGroup</a> that only has `READ` permission
result in the `transactionAllowed` method returning `res: false` for that transaction.

  <pre class="solidity">
pragma solidity ^0.5.1;
import "./MemberGroup.sol";
import "./AuthorizedUser.sol";
import "./PermissioningDecider.sol";
interface Network {

    // Node queries.

    // Retrieve the memberGroup that a node is part of.
    function memberGroupOf(string calldata _node) external view
        returns (MemberGroup);

    // Retrieve the number of nodes in the memberGroup.
    function memberGroupsNodeCount(MemberGroup) external view
        returns (uint);

    // Retrieve a node, specified by index idx, from the memberGroup.
    function memberGroupsNode(MemberGroup, uint idx) external view
        returns (string memory);

    // Authorization queries.

    // Retrieve the permissions for the memberGroup.
    function permission(MemberGroup) external view returns (uint);

    // Check if 2 nodes are allowed to connect to one another
    function connectionAllowed(
        bytes32 sourceEnodeHigh,
        bytes32 sourceEnodeLow,
        bytes32 sourceIp,
        bytes32 sourcePort,
        bytes32 destinationEnodeHigh,
        bytes32 destinationEnodeLow,
        bytes32 destinationIp,
        bytes32 destinationPort
    ) external view returns (bytes32);

    // Group administration.

    // Add a node to a memberGroup. This will fail unless the authorizedUser has
    // `CAN_ADD_NODE` permission.
    function addNode(MemberGroup, AuthorizedUser, string calldata _node) external;

    // Remove a node from a memberGroup. This will fail unless the authorizedUser has
    // `CAN_REMOVE_NODE` permission
    function removeNode(MemberGroup, AuthorizedUser, string calldata _node) external;

    // Group membership queries.

    // Retrieve the number of memberGroups.
    function memberGroupCount() external view returns (uint);

    // Retrieve a memberGroup, specified by index idx
    function getmemberGroup(uint idx) external view
        returns (MemberGroup);

    // Network vote counts.

    // Retrieve the number of invites for the memberGroup to have `READ`
    // permissions in the context of the network.
    function readInvitesReceived(MemberGroup) external view
        returns (uint);

    // Retrieve the number of invites for the memberGroup to have `WRITE`
    // permissions in the context of the network.
    function writeInvitesReceived(MemberGroup) external view
        returns (uint);

    // Retrieve the number of uninvites for the memberGroup to leave the
    // network.
    function uninvitesReceived(MemberGroup) external view returns (uint);

    // Group membership mutators.

    // Invite a memberGroup to join the network. This will fail unless the authorizedUser has
    // `CAN_INVITE_MEMBERGROUP` permission.
    function invite(MemberGroup _invitee, MemberGroup _ginviter,
                          AuthorizedUser _uinviter, string calldata _node, uint _perm) external;

    // Uninvite a memberGroup from the network. This will fail unless the authorizedUser has
    // `CAN_UNINVITE_MEMBERGROUP` permission.
    function uninvite(MemberGroup _invitee, MemberGroup _ginviter,
                          AuthorizedUser _uinviter) external;

    // Rule inspection.

    // Retrieve the permission decider function currently in use.
    function decider() external view returns (PermissioningDecider);

    // Rule vote counts.

    // Retrieve the number of votes received for the permissioning decider.
    function deciderVotesReceived(PermissioningDecider) external view
        returns (uint);

    // Retrieve the permissioning decider nominated by the memberGroup.
    // Useful for admin weighting.
    function nominatedDecider(MemberGroup) external view
        returns (PermissioningDecider);

    // Change the rule engine.

    // Propose a new permissioning decider.
    function proposeDecider(PermissioningDecider _next,
                                MemberGroup _gproposer, AuthorizedUser _uproposer)
                                external;
    // Emitted events.

    // The permissions set was updated
    event NodePermissionsUpdated(bool addsRestrictions);

    // A node was added to a memberGroup.
    event NodeAdded(MemberGroup _changed_group, string _node);

    // A node was removed from a memberGroup.
    event NodeRemoved(MemberGroup _changed_group, string _node);

    // An authorizedUser has invited a memberGroup to join the network.
    event memberGroupInvited(MemberGroup _invited_group,
                                    uint _permission);

    // An authorizedUser has uninvited a memberGroup from the network.
    event memberGroupUnInvited(MemberGroup _uninvited_group,
                                    uint _permission);

    // A memberGroup was added to the network.
    event memberGroupAdded(MemberGroup _added_group,
                                    uint _permission);

    // A memberGroup was removed from the network.
    event memberGroupRemoved(MemberGroup _removed_group,
                                    uint _permission);

    // A permission decider function was swapped to a new one.
    event DeciderSwapped(PermissioningDecider _old, PermissioningDecider _new);
}
  </pre>

The `Network` contract checks whether the caller has permission to call the `invite`,
`uninvite`, `proposeDecider`, `addNode`, and `removeNode` functions. The granularity of
permissions is implementation-dependent.

        </section>

        <section id="sec-network-permissioning-permissioningdecider">

        <h5>PermissioningDecider</h5>

The `PermissioningDeciders` <a>smart contract</a> customizes the bylaws of a
`Network` <a>smart contract</a>.

  <pre class="solidity">
pragma solidity ^0.5.1;
import "./MemberGroup.sol";
import "./Network.sol";
interface PermissioningDecider {

    // The permission the memberGroup now has, if approved.
    function inviteApproved(Network, MemberGroup) external view
        returns (uint8);

    // Whether the network should remove the memberGroup.
    function inviteRevoked(Network, MemberGroup) external view
        returns (bool);

    // Whether the network should change its permissioning decider.
    function swapDecider(Network, PermissioningDecider) external view
        returns (bool);
}
  </pre>

Some example `PermissioningDeciders` include:

- Static: `memberGroups` are never removed or added from the `Network`. Any attempt
to change the `PermissioningDecider` will fail.
- AutoApprove: `memberGroups` are automatically included (or removed) when
invited (or uninvited). The decider swaps the first time it is asked.
- AdminRun: The `Network` has an administrator group, which is the only vote
counted for approving or revoking approval of a `memberGroup`, or changing
the `PermissionDecider`.
- MajorityRules: A prospective `memberGroup` needs more than half of the
current `memberGroups` to invite it for membership. A prospective
`PermissioningDecider` needs more than half of the current groups to nominate it
before this `Decider` relinquishes control.

       </section>

       <section id="sec-network-permissioning-node-blacklisting">

       <h5>Node Blacklisting</h5>

Blacklisting a <a>node</a> from a <a>memberGroup</a> level can be done by by adding
the following functions to the <code>MemberGroup</code> <a>smart contract</a>.

  <pre class="solidity">
interface MemberGroup {

    ...
    // Blacklist an authorizedUser.
    function blacklistNode(AuthorizedUser, string _node) interface;

    // Remove an authorizedUser from the blacklist.
    function unblacklistNode(AuthorizedUser, string _node) interface;
    ...

}
  </pre>

Blacklisting of <a>nodes</a> for the whole <a>Enterprise Ethereum blockchain</a> can be done by adding
the following functions to the `Network` and `PermissioningDecider` <a>smart contracts</a>.

  <pre class="solidity">
interface Network {

    ...
    // Vote to add an authorizedUser to the blacklist.
    voteToBlacklist(MemberGroup, AuthorizedUser, string _node) external;

    // Vote to remove an authorizedUser from the blacklist.
    voteToUnblacklist(MemberGroup, AuthorizedUser, string _node) external;

    // Retrieve the number of votes for the node to be added to the blacklist.
    blacklistVotesReceived(string _node) external view returns (uint);

    // Retrieve the number of votes for the node to be removed from the
    // blacklist.
    unblacklistVotesReceived(string _node) external view returns (uint);

    // Emitted when a node is added to the blacklist.
    event NodeBlacklisted(MemberGroup _blacklisted_group, string _node);

    // Emitted when a node is removed from the blacklist.
    event NodeUnblacklisted(MemberGroup _unblacklisted_group, string _node);
    ...

}
  </pre>

  <pre class="solidity">
interface PermissioningDecider {

...
// Whether the node should be added to the blacklist.
function blacklistApproved(Network, string _node) external view
    returns (bool);

// Returns whether the node should be removed from the blacklist.
function unblacklistApproved(Network, string _node) external view
    returns (bool);
...

}
  </pre>

        </section>

        </aside>

      </section>

    </section>

      <section id="sec-inter-chain" class="informative">

      <h4>Inter-chain</h4>

With the rapid expansion in the number of different blockchains and ledgers,
<dfn data-lt="inter-chain mediator">inter-chain mediators</dfn> allow
interaction between these blockchains. Like other solutions that provide
<a>privacy</a> and scalability, inter-chain mediators can be built in Layer 2,
such as using <a>public Ethereum</a> to anchor state as needed for tracking and checkpoints.

      </section>

      <section id="sec-oracles">

      <h4>Oracles</h4>

In many situations, <a>smart contracts</a> need to interact with real-world
information to operate. An <dfn data-lt="oracles">oracle</dfn> is a service
external to either <a>public Ethereum</a> or an <a>Enterprise Ethereum client</a>
that is trusted by the creators of <a>smart contracts</a> and is
called to provide information, such as a current exchange rate, or the result of
a mathematical calculation. Oracles are a secure bridge between
<a>smart contracts</a> and real-world information sources.

  <p id="req-orcl-010">
<b>[C] ORCL-010:</b> <a>Enterprise Ethereum clients</a> SHOULD provide
the ability to securely interact with <a>oracles</a> to send and receive
external off-chain information.
  </p>

      </section>

    </section>

  </section>
  
  
  
        <section id="sec-messages">
  
        <h4>Message Structures</h4>

This section defines the structures of the "BFT" sub-protocol messages communicated between ethereum nodes. All messages MUST be encoded using RLP encoding serialisation as specified in [https://github.com/ethereum/wiki/wiki/RLP].

For any type of message, the signature corresponds to the hash over the message using the validator private key:

<code>hashForMessageSignature(message) = KEC(concatenate(message.ID, RLP(message.payload)))</code>


          <section id="sec-msg-propose">

          <h5>Proposal</h5>

  The block proposer must send the <a>Proposal</a> message to all other validators at the beginning of any round.

  **Message content**

  The <a>Proposal</a> message contains the following fields:

  - `0x00` DATA, x? bytes – The message id for the <a>Proposal</a> message type.
  - `payload` – A list containing each of the following:
  
      - `height` QUANTITY, 8 bytes – The <a>height</a> of the block being proposed, as an integer.
      - `round` QUANTITY, 4 bytes – The <a>round</a> number, as an integer.
      - `digest` DATA, 32 bytes – The Keccak hash of the proposed block.
  - `signature` DATA, 65 bytes – The <a>signature</a> of the payload.
  - `proposedBlock` – The content of the proposed block in ethereum block format.

          </section>
		  
          <section id="sec-msg-prepare">

          <h5>Prepare</h5>

  The <a>Prepare</a> message MUST be sent when a validator that is not the designated block proposer for a round receives a <a>Proposal</a> message.
  
  **Message content**

  The <a>Prepare</a> message contains the following fields:

  - `0x01` DATA, x? bytes – The message id for the <a>Prepare</a> message type.
  - `payload` – A list containing each of the following:
  
      - `height` QUANTITY, 8 bytes – The <a>height</a> of the block being prepared, as an integer.
      - `round` QUANTITY, 4 bytes – The <a>round</a> number, as an integer.
      - `digest` DATA, 32 bytes – The <a>digest</a> of the prepared block?
  - `signature` DATA, 65 bytes – The <a>signature</a> of the payload.

          </section>

          <section id="sec-msg-commit">

          <h5>Commit</h5>

  The <a>Commit</a> message MUST be sent by a validator when "enough" <a>Prepare</a> messages matching the  <a>Proposal</a> sent by the designated proposer      mof the round are received.
  
  **Message content**

  The <a>Commit</a> message contains the following fields:

  - `0x02` DATA, x? bytes – The message id for the <a>Commit</a> message type.
  - `payload` – An array of one or more of the following:
  
      - `height` QUANTITY, 8 bytes – The <a>height</a> of the block being prepared, as an integer.
      - `round` QUANTITY, 4 bytes – The <a>round</a> number, as an integer.
      - `digest` DATA, 32 bytes – The <a>digest</a> of the prepared block?
      - `commitSeal` DATA, 32 bytes – The signature of the validator over the proposed block included in the <a>Proposal</a> or <a>New-Round</a> message received by the designated proposer of the round.
  - `signature` DATA, 65 bytes – The <a>signature</a> of the payload.

          </section>
		  		 				    

  </section>
  
  <section id="sec-privacy-and-scaling-layer-main">

  <h2>Privacy and Scaling Layer</h2>

The Privacy and Scaling layer implements the necessary <a>privacy</a> and
scaling extensions needed in <a>Enterprise Ethereum</a> to support
enterprise-grade deployments.

For the purpose of this Specification:

  <ul>
    <li>
<dfn>Privacy</dfn>, as used in this specification means enabling <a>users</a>
or <a>organizations</a> to know how information about transactions they initiate
can be collected and stored, and who can disclose that information to whom.
    </li>
    <li>
A <dfn data-lt="transactions|transact|transacting">transaction</dfn> is a
request to execute operations that change the state of an <a>Enterprise Ethereum blockchain</a>.
Transactions can involve one or more <a>accounts</a>.
    </li>
    <li>
A <dfn data-lt="private transactions|transaction privacy">private transaction</dfn>
is a <a>transaction</a> where some information about the <a>transaction</a>,
such as the <a>payload data</a>, or the sender or the recipient, is only
available to the subset of parties privy to that <a>transaction</a>.
    </li>
  </ul>

  <p>
<a>Enterprise Ethereum</a> implementations are required to support
<a>private transactions</a>, as outlined in Section
<a href="#sec-private-transactions"></a>.
  </p>

  <p>
<a>Enterprise Ethereum</a> implementations can also support off-chain
<a data-lt="TCS">Trusted Computing</a>, enabling <a>privacy</a> during code
execution.
  </p>

This Specification does not constrain experimentation to improve the
scalability of future <a>public Ethereum</a> or <a>Enterprise Ethereum clients</a>.
Most likely several forms of scaling improvements will be made over time,
that cannot be exactly predicted.

Scaling solutions are broadly categorized into:

- <a data-lt="onchain layer 1 scaling">Layer 1 scaling</a> solutions, which are
implemented at the base level protocol layer, and might be implemented using
techniques such as [[sharding]] and easy parallelizability [[EIP-648]].
- <a data-lt="onchain layer 2 scaling">Layer 2 scaling</a> solutions, which do
not require changes to the base level protocol layer and are implemented at the
application protocol layer using <a>smart contracts</a>, [[Plasma]] or
[[state-channels]] as well as other
<a data-lt="offchain compute scaling">Off-Chain (Compute) scaling</a>
mechanisms.

Similarly, various <a>on-chain privacy mechanisms</a> are being explored.
<dfn data-lt="onchain privacy">On-chain privacy mechanisms</dfn> are extensions
to <a>public Ethereum</a>, such as <a>zero-knowledge proofs</a>, or privacy-preserving
<a>trusted computing</a>, enabling <a>private transactions</a>.

A <dfn data-lt="zero-knowledge proofs">zero-knowledge proof</dfn> is a
cryptographic method where one party (the prover) can prove to another party
(the verifier) that the prover knows a value x, without conveying any
information apart from the fact that the prover knows the value x. [[ZK-STARKS]]
is an example of a zero-knowledge proof method.
    <section id="sec-privacy-sublayer">

    <h3>Privacy Sublayer</h3>

  <p>
<a>Enterprise Ethereum clients</a> allow <a>private transactions</a>.
<a>Privacy</a> can be realized in various ways, including controlling which
<a>nodes</a> see <a>private transactions</a>, or <a>transaction</a> data.
Options for implementing compliant <a>privacy</a> levels are detailed in Section
<a href="#sec-privacy-levels"></a>
  </p>.

      <section id="sec-on-chain" class="informative">

      <h4>On-chain</h4>

Various on-chain techniques are proposed to improve the security and
<a>privacy</a> capabilities of <a>Enterprise Ethereum blockchains</a>.


  <aside class="note" title="On-chain Security Techniques">
Future on-chain security techniques could include techniques such as ZK-STARKS,
range proofs, or ring signatures.
  </aside>

      </section>

      <section id="sec-off-chain" class="informative">

      <h4>Off-chain (Trusted Computing)</h4>

  <p>
<dfn data-lt="trusted computing|TCS">Off-chain trusted computing</dfn> is the
offloading of computationally intensive processing while still maintaining
<a>transaction</a> privacy.
<a>Transactions</a> and <a>smart contracts</a> are executed outside the core
blockchain for improved <a>privacy</a>, <a>performance</a>, or security. Such
systems could be hardware-based, software-based, or both, depending on the use
case.
  </p>

  <p>
The EEA has developed Trusted Compute APIs for Ethereum-compatible
<a>trusted computing</a> [[EEA-OC]].
  </p>

  <p>
<a>Enterprise Ethereum clients</a> could provide
<a data-lt="TCS">off-chain trusted compute</a> of <a>transactions</a> by
implementing requirement <a href="#req-exec-050">EXEC-050</a>.
  </p>

      </section>

      <section id="sec-private-transactions">

      <h4>Private Transactions</h4>

Many users and operators of <a>Enterprise Ethereum clients</a> are
required by their legal jurisdictions to comply with laws and regulations
related to <a>privacy</a>. For example, banks in the European Union are
required to comply with the European Union revised Payment Services Directive
[[PSD2]] when providing payment services, and the General Data Protection
Regulation [[GDPR]] when storing personal data regarding individuals.

<a>Enterprise Ethereum</a> <a>users</a> specify their preferred
<a>private transaction</a> type at runtime by using the `restriction` parameter
on their [[JSON-RPC-API]] calls. The two available <a>private transaction</a>
types are:

  <ul>
    <li>
<dfn>Restricted private transactions</dfn>, where <a>payload data</a> is
transmitted to and readable only by the parties to the <a>transaction</a>.
    </li>
    <li>
<dfn>Unrestricted private transactions</dfn>, where <a>payload data</a> is
transmitted to all <a>nodes</a> in the <a>Enterprise Ethereum blockchain</a>,
but readable only by the parties to the <a>transaction</a>.
    </li>
  </ul>

  <p id="req-priv-010">
<b>[P] PRIV-010:</b> <a>Enterprise Ethereum clients</a> MUST support <a>private transactions</a>
using either <a>restricted private transactions</a> or <a>unrestricted private transactions</a>.
  </p>

  <p>
<a>Transaction</a> information consists of two parts:
  </p>

  <ul>
    <li>
<dfn>Metadata</dfn>, which is the set of data that describes and gives
information about the <a>payload data</a> in a <a>transaction</a>. Metadata is
the <em>envelope</em> information necessary to execute a <a>transaction</a>.
    </li>
    <li>
<dfn>Payload data</dfn>, which is the content of the data field of a
<a>transaction</a>, usually obfuscated in <a>private transactions</a>. Payload
data is separate from the <a>metadata</a> in a <a>transaction</a>.
    </li>
  </ul>

  <p id="reqgrp-priv-grp1">
If implementing <a>restricted private transactions</a>:
  </p>

  <ul>
      <li id="req-priv-020">
<b>[P] PRIV-020:</b> <a>Enterprise Ethereum clients</a> MUST encrypt
<a>payload data</a> when stored in <a>restricted private transactions</a>.
      </li>
      <li id="req-priv-030">
<b>[P] PRIV-030:</b> <a>Enterprise Ethereum clients</a> MUST encrypt
<a>payload data</a> when in transit in <a>restricted private transactions</a>.
      </li>
      <li id="req-priv-040">
<b>[P] PRIV-040:</b> <a>Enterprise Ethereum clients</a> MAY encrypt
<a>metadata</a> when stored in <a>restricted private transactions</a>.
      </li>
      <li id="req-priv-050">
<b>[P] PRIV-050:</b> <a>Enterprise Ethereum clients</a> MAY encrypt
<a>metadata</a> when in transit in <a>restricted private transactions</a>.
      </li>
      <li id="req-priv-060">
<b>[P] PRIV-060:</b> <a>Nodes</a> that relay a
<a>restricted private transaction</a>, but are not party to that
<a>transaction</a>, MUST NOT store the <a>payload data</a>.
      </li>
      <li id="req-priv-070">
<b>[P] PRIV-070:</b> <a>Nodes</a> that relay a
<a>restricted private transaction</a>, but are not party to that
<a>transaction</a>, SHOULD NOT store the <a>metadata</a>.
      </li>
      <li id="req-priv-080">
<b>[P] PRIV-080:</b> The implementation of the
<code>eea_sendTransactionAsync</code>, <code>eea_sendTransaction</code>,
<code>eea_sendRawTransactionAsync</code>, or <code>eea_sendRawTransaction</code>
methods (see Section <a href="#sec-extensions-json-rpc"></a>) with the
<code>restriction</code> parameter set to <code>restricted</code>, MUST result
in a <a>restricted private transaction</a>.
      </li>
  </ul>

  <aside class="note" title="Restricted Private Transactions">
    <p>
<a>Private transactions</a> can be implemented by creating private channels,
that is, private <a>smart contracts</a> where the <a>payload data</a> is only
stored by the <a>clients</a> participating in a <a>transaction</a>, and not by
any other <a>client</a> (despite that the <a>payload data</a> might be encrypted
and only decodable by authorized parties).
    </p>

    <p>
<a>Private transactions</a> are kept private between related parties, so
unrelated parties have no access to the content of the <a>transaction</a>, the
sending party, or the addresses of <a>accounts</a> party to the transaction. In
fact, a private <a>smart contract</a> has a similar relationship to the
blockchain that hosts it as a private blockchain that is only replicated
and certified by a subset of participating <a>nodes</a>, but is notarized and
synchronized on the hosting blockchain. This private blockchain is thus able to
refer to data in less restrictive private <a>smart contracts</a>, as well as in
public <a>smart contracts</a>.
    </p>
  </aside>

  <p id="reqgrp-priv-grp2">
If implementing <a>unrestricted private transactions</a>:
  </p>

    <ul>
      <li id="req-priv-090">
<b>[P] PRIV-090:</b> <a>Enterprise Ethereum clients</a> SHOULD encrypt
the recipient identity when stored in <a>unrestricted private transactions</a>.
      </li>
      <li id="req-priv-100">
<b>[P] PRIV-100:</b> <a>Enterprise Ethereum clients</a> SHOULD encrypt
the sender identity when stored in <a>unrestricted private transactions</a>.
      </li>
      <li id="req-priv-110">
<b>[P] PRIV-110:</b> <a>Enterprise Ethereum clients</a> SHOULD encrypt
the <a>payload data</a> when stored in <a>unrestricted private transactions</a>.
      </li>
      <li id="req-priv-120">
<b>[P] PRIV-120:</b> <a>Enterprise Ethereum clients</a> MUST encrypt
<a>payload data</a> when in transit in <a>unrestricted private transactions</a>.
      </li>
      <li id="req-priv-130">
<b>[P] PRIV-130:</b> <a>Enterprise Ethereum clients</a> MAY encrypt
<a>metadata</a> when stored in <a>unrestricted private transactions</a>.
      </li>
      <li id="req-priv-140">
<b>[P] PRIV-140:</b> <a>Enterprise Ethereum clients</a> MAY encrypt
<a>metadata</a> when in transit in <a>unrestricted private transactions</a>.
      </li>
      <li id="req-priv-150">
<b>[P] PRIV-150:</b> <a>Nodes</a> that relay an
<a>unrestricted private transaction</a>, but are not party to that
<a>transaction</a>, MAY store the <a>payload data</a>.
      </li>
      <li id="req-priv-160">
<b>[P] PRIV-160:</b> <a>Nodes</a> that relay an
<a>unrestricted private transaction</a>, but are not party to that
<a>transaction</a>, MAY store the <a>metadata</a>.
      </li>
      <li id="req-priv-170">
<b>[P] PRIV-170:</b> The implementation of the
<code>eea_sendTransactionAsync</code>, <code>eea_sendTransaction</code>,
<code>eea_sendRawTransactionAsync</code>, or <code>eea_sendRawTransaction</code>
methods (see Section <a href="#sec-extensions-json-rpc"></a>) with the
<code>restriction</code> parameter set to <code>unrestricted</code> MUST result
in an <a>unrestricted private transaction</a>.
      </li>
      <li id="req-priv-210">
<b>[P] PRIV-210:</b> <a>Enterprise Ethereum clients</a>' implementation of
<a>unrestricted private transactions</a> MUST provide the ability for <a>nodes</a>
to achieve global <a>consensus</a>.
      </li>
    </ul>

  <aside class="note" title="Unrestricted Private Transactions">
    <p>
Obfuscated data that is replicated across all <a>nodes</a> can be
reconstructed by any <a>node</a>, albeit in encrypted form. Mathematical
<a>transactions</a> on numerical data are intended to be validated by the
underlying <a>Enterprise Ethereum blockchain</a> on a
<a data-lt="zero-knowledge proof">zero-knowledge</a>
basis. The plaintext content is only available to participating parties to the
<a>transaction</a>. Thus, a <a>node</a> is expected to have the ability to
maintain and transact against numerical balances certified by the whole
community of validators on a
<a data-lt="zero-knowledge proof">zero-knowledge</a> basis.
    </p>

    <p>
An alternative to the <a data-lt="zero-knowledge proof">zero-knowledge</a>
approach could be the combined use of ring signatures, stealth addresses, and
mixing, which is demonstrated to provide the necessary level of obfuscation that
is mathematically impossible to penetrate and does not rely on the trusted setup
required by ZK-SNARKS.
    </p>
  </aside>

  <p id="req-priv-180">
<b>[P] PRIV-180:</b> <a>Enterprise Ethereum clients</a> SHOULD be able to extend the set of
parties to a <a>private transaction</a> (or forward the <a>private transaction</a> in some way).
  </p>

  <p id="req-priv-190">
<b>[P] PRIV-190:</b> <a>Enterprise Ethereum clients</a> SHOULD provide the ability for
<a>nodes</a> to achieve <a>consensus</a> on their mutually <a>private transactions</a>.
  </p>

  <p>
The differences between <a>restricted private transactions</a> and
<a>unrestricted private transactions</a> are summarized in the table below.
  </p>

    <table>
      <caption>Table 2 Restricted and Unrestricted Private Transactions</caption>
        <thead>
          <tr class="header">
            <th colspan="2">Restricted Private TXNs (if implemented)</th>
            <th colspan="2">Unrestricted Private TXNs (if implemented)</th>
          </tr>
        </thead>
        <tbody>
          <tr class="odd">
            <td>Metadata</td>
            <td>Payload Data</td>
            <td>Metadata</td>
            <td>Payload Data</td>
          </tr>
          <tr class="even">
            <td>MAY encrypt</td>
            <td>MUST encrypt</td>
            <td><p>MAY encrypt</p>
                <p>SHOULD encrypt sender and recipient identity</p></td>
            <td><p>MUST encrypt in transit</p>
                <p>SHOULD encrypt in storage</p></td>
          </tr>
          <tr class="odd">
            <td>SHOULD NOT allow storage by non-participating <a>nodes</a></td>
            <td>MUST NOT allow storage by non-participating <a>nodes</a></td>
            <td>MAY allow storage by non-participating <a>nodes</a></td>
            <td>MAY allow storage by non-participating <a>nodes</a></td>
          </tr>
        </tbody>
    </table>

      </section>

      <section id="sec-privacy-levels" class="informative">

      <h4>Privacy Levels</h4>

Compliance with this Specification allows for three levels of <a>privacy</a>
support. Because <a>permissioning</a> and <a>privacy</a> are interrelated
concepts, the three <a>privacy</a> levels specified contain requirements related
to both the <a>permissioning</a> and <a>privacy</a> sections of this
Specification.

        <section id="sec-privacy-level-c">

        <h5>Privacy Level C</h5>

Privacy Level C is the base privacy level for all compliant implementations.
Privacy Level C compliance is achieved by implementing all the MUST
peer <a>node</a> connectivity and account <a>permissioning</a> requirements
in Sections <a href="#sec-nodes"></a> and <a href="#sec-participants"></a>, and
either:
-  All MUST and MUST NOT <a>restricted private transaction</a>
<a href="#reqgrp-priv-grp1">requirements</a>, as outlined in Section
<a href="#sec-private-transactions"></a>, or
-  All MUST and MUST NOT <a>unrestricted private transaction</a>
<a href="#reqgrp-priv-grp2">requirements</a>, as outlined in Section
<a href="#sec-private-transactions"></a>.

        </section>

        <section id="sec-privacy-level-b">

        <h5>Privacy Level B</h5>

Supporting additional SHOULD requirements increases the <a>privacy</a> and
<a>permissioning</a> abilities for an <a>Enterprise Ethereum client</a>,
adding specific value for users.

Privacy Level B compliance is achieved by providing support for the requirements
of Privacy Level C, plus implementing all the SHOULD requirements related to
peer <a>node</a> connectivity and account <a>permissioning</a> requirements
in Sections <a href="#sec-nodes"></a>, <a href="#sec-participants"></a>, and
<a href="#sec-additional-permissioning-requirements"></a>.

<a>Enterprise Ethereum client</a> obtaining Privacy Level B demonstrate increased interoperability
with the <a>public Ethereum</a> ecosystem and other <a>Enterprise Ethereum client</a>.

        </section>

        <section id="sec-privacy-level-a">

        <h5>Privacy Level A</h5>

Privacy Level A compliance is achieved by providing support for the requirements
of Privacy Level B, plus implementing all the SHOULD and SHOULD NOT requirements
in Section <a href="#sec-private-transactions"></a>.

<a>Enterprise Ethereum clients</a> implementing Privacy Level A demonstrate
increased security and <a>privacy</a> protections for their users.
Privacy Level A is considered best practice for <a>Enterprise Ethereum clients</a>
and is strongly encouraged.

        </section>

        <section id="sec-privacy-level-summary">

        <h5>Privacy Level Certification</h5>

EEA certification programs will recognize <a>Enterprise Ethereum clients</a> providing support
for Privacy Levels A, B, or C. Certificates of Certification are subject to the
unique requirements of EEA-approved vertical business segments.

The following table summarizes the three privacy level requirements.

<table>
  <caption>Table 3 Summary of Privacy Levels</caption>
  <thead>
    <tr class="header">
      <th>Privacy&nbsp;Level</th>
      <th>Description</th>
      <th>Implementations Provide Support For</th>
    </tr>
  </thead>
  <tbody>
    <tr class="odd">
      <td>C</td>
      <td>Baseline <a>privacy</a> and <a>permissioning</a></td>
      <td>
All the MUST peer <a>node</a> connectivity and <a>permissioning</a> requirements
from Sections <a href="#sec-nodes"></a> and <a href="#sec-participants"></a>,
and either:
          <ul>
            <li>
All MUST and MUST NOT <a>Restricted private transaction</a>
<a href="#reqgrp-priv-grp1">requirements</a> in Section
<a href="#sec-private-transactions"></a>, or
            </li>
            <li>
All MUST and MUST NOT <a>Unrestricted private transaction</a>
<a href="#reqgrp-priv-grp2">requirements</a> in Section
<a href="#sec-private-transactions"></a>.
            </li>
          </ul>
      </td>
    </tr>
    <tr class="even">
      <td>B</td>
      <td>Best practice <a>permissioning</a></td>
      <td>
Privacy Level C plus all the SHOULD peer
<a>node</a> connectivity and <a>permissioning</a> requirements from Sections
<a href="#sec-nodes"></a>, <a href="#sec-participants"></a>, and
<a href="#sec-additional-permissioning-requirements"></a>.
    </td>
    </tr>
    <tr class="odd">
      <td>A</td>
      <td>Best practice <a>privacy</a> and <a>permissioning</a></td>
      <td>
Privacy Level B and all the SHOULD and SHOULD NOT requirements in Section
<a href="#sec-private-transactions"></a>.
      </td>
    </tr>
  </tbody>
</table>

        </section>

      </section>

    </section>

    <section id="sec-scaling-sublayer" class="informative">

    <h3>Scaling Sublayer</h3>

  <p>
<a>Enterprise Ethereum blockchains</a> will likely have demands placed on them to
handle higher volume <a>transaction</a> rates and potentially computationally
heavy tasks. Various scaling methods can be employed to increase
<a>transaction</a> processing rates.
  </p>

      <section id="sec-on-chain-layer-1-and-layer-2">

      <h4>On-chain (Layer 1 and Layer 2)</h4>

  <p>
Techniques to improve scalability are valuable for blockchains with high
<a>transaction</a> throughput requirements combined with a desire or need to
keep the processing on the blockchain.
  </p>

  <p>
<dfn data-lt="onchain layer 1 scaling">On-chain (layer 1) scaling</dfn>
techniques, like [[sharding]], are changes or extensions to the
<a>public Ethereum</a> protocol to facilitate increased <a>transaction</a>
speeds.
  </p>

  <p>
<dfn data-lt="onchain layer 2 scaling">On-chain (layer 2) scaling</dfn>
techniques, like using <a>smart contracts</a>, [[Plasma]], or
[[state-channels]], facilitate increased <a>transactions</a> speeds without
changing the underlying <a>Ethereum</a> protocol.  For more information, see
[[Layer2-Scaling-Solutions]].
  </p>

      </section>

      <section id="sec-off-chain-compute">

      <h4>Off-chain (Layer 2 Compute)</h4>

  <p>
<dfn data-lt="offchain compute scaling">Off-chain (layer 2 compute) scaling</dfn>
is where processing is executed externally to the <a>Ethereum</a> blockchain
to facilitate increased <a>transaction</a> speeds.
For example, offloading computationally
intensive tasks to one or more <a data-lt="TCS">Trusted Computing services</a>.
  </p>

  <p>
<a>Enterprise Ethereum clients</a> could provide
<a data-lt="offchain compute scaling">off-chain scaling</a> functionality by
implementing requirement <a href="#req-exec-050">EXEC-050</a>.
  </p>

      </section>

      <section id="sec-performance">

      <h4>Performance</h4>

  <p>
<dfn>Performance</dfn> is the total effectiveness of a system, including
overall throughput, individual <a>transaction</a> time, and system availability.
For <a>Enterprise Ethereum</a>, this refers to the overall performance of the
<a>Enterprise Ethereum blockchain</a>. Ideally, increased usage of the
<a>Enterprise Ethereum blockchain</a> does not degrade its performance.
  </p>

  <aside class="example" title="EEA Certification">
    <p>
Certificates of Certification could require minimum <a>transaction</a> rates in
terms of [[ERC-20]] <a>smart contract</a> executions per second, or other
measures.
    </p>
  </aside>

      </section>

    </section>

  </section>

  <section id="sec-core-blockchain-layer-main">

  <h2>Core Blockchain Layer</h2>

The Consensus sublayer provides a mechanism to establish <a>consensus</a>
between <a>nodes</a>.

<dfn>Consensus</dfn> is the process of <a>nodes</a> on a blockchain reaching
agreement about the current state of the blockchain.

A <dfn data-lt="consensus algorithms">consensus algorithm</dfn> is the
mechanism by which a blockchain achieves <a>consensus</a>. Different blockchains
can use different consensus algorithms, but all <a>nodes</a> of a given
blockchain need to use the same consensus algorithm. Different consensus
algorithms are available for both <a>public Ethereum</a> and
<a>Enterprise Ethereum</a>.

<a>Enterprise Ethereum clients</a> can provide additional
<a>consensus algorithms</a> for operations within their private
<dfn data-lt="consortium networks">consortium network</dfn> (an <a>Ethereum</a> blockchain,
either <a>public Ethereum</a> or <a>Enterprise Ethereum</a>, which is not part of the
<a>Ethereum MainNet</a>).

  <aside class="example" title="Consensus Algorithms">
An example public <a>consensus algorithm</a> is the Proof of Work (PoW)
algorithm, which is described in the [[Ethereum-Yellow-Paper]]. Over time, PoW
is likely to be phased out from use and replaced with new methods of
<a>consensus</a>. Other example <a>consensus algorithms</a> include Istanbul
[[Byzantine-Fault-Tolerant]] (IBFT) [[EIP-650]], [[RAFT]], and Proof of Elapsed
Time [[PoET]].
  </aside>

The Execution sublayer implements the
<dfn data-lt="EVM">Ethereum Virtual Machine</dfn> (EVM), which is a runtime
computing environment for the execution of <a>smart contracts</a>. Each <a>node</a>
operates an EVM.

Ethereum-flavored WebAssembly [[eWASM]], which has its own instruction set,
and other computational capabilities as required, are implemented at this layer.

<dfn data-lt="smart contract|contract|contracts">Smart contracts</dfn> are
computer programs that the <a>EVM</a> executes.
Smart contracts can be written in higher-level programming languages and compiled to
<a>EVM</a> bytecode. Smart contracts can implement a contract between parties,
where the execution is guaranteed and auditable to the level of security provided by <a>Ethereum</a>
itself.

A <dfn data-lt="precompiled contracts">precompiled contract</dfn> is a
<a>smart contract</a> compiled in <a>EVM</a> bytecode and stored by a <a>node</a>.

Finally, the Storage and Ledger sublayer is provided to store the blockchain
state, such as <a>smart contracts</a> for later execution. This sublayer follows
blockchain security paradigms such as using cryptographically hashed tries, a
UTXO model, or at-rest-encrypted key-value stores.


    <section id="sec-storage-and-ledger-sublayer">

    <h3>Storage and Ledger Sublayer</h3>

To operate a <a>client</a> on the <a>Ethereum MainNet</a>, and to support
optional off-chain operations, local data storage is required. For example,
<a>Enterprise Ethereum clients</a> can locally cache the results from a trusted <a>oracle</a> or
store information related to systems extensions beyond the scope of this
Specification.

  <p id="req-stor-030">
<b>[C] STOR-030:</b> <a>Enterprise Ethereum clients</a> providing support for multiple blockchains
(for example, more than one <a>Enterprise Ethereum blockchain</a>, or a public network) MUST
store data related to restricted <a>private transactions</a> for those blockchains
in <a>private state</a> dedicated to the relevant blockchain.
  </p>

  <p>
<dfn>Private State</dfn> is the state data that is not shared in the clear in
the globally replicated state tree. This data can represent bilateral or
multilateral arrangements between parties, for example in
<a>private transactions</a>.
  </p>

  <p id="req-stor-040">
<b>[P] STOR-040:</b> <a>Enterprise Ethereum clients</a> SHOULD permit a
<a>smart contract</a> operating on <a>private state</a> to access <a>private state</a>
created by other <a>smart contracts</a> involving the same parties to the <a>transaction</a>.
  </p>

  <p id="req-stor-050">
<b>[P] STOR-050:</b> <a>Enterprise Ethereum clients</a> MUST NOT permit
<a>smart contract</a> operating on <a>private state</a> to access <a>private state</a>
created by other <a>smart contracts</a> involving different parties to the <a>transaction</a>.
  </p>

  <p id="req-stor-070">
<b>[P] STOR-070:</b> If an <a>Enterprise Ethereum client</a> stores <a>private state</a>
persistently, it SHOULD protect the data using an Authenticated Encryption with
Additional Data (AEAD) algorithm, such as one described in [[RFC5116]].
  </p>

    </section>

    <section id="sec-execution-sublayer">

    <h3>Execution Sublayer</h3>

  <p id="req-exec-010">
<b>[P] EXEC-010:</b> <a>Enterprise Ethereum clients</a> MUST provide a
<a>smart contract</a> execution environment implementing the
<a>public Ethereum</a> <a>EVM</a> op-code set [[!EVM-Opcodes]].
  </p>

  <p id="req-exec-020">
<b>[P] EXEC-020:</b> <a>Enterprise Ethereum clients</a> MAY provide a
<a>smart contract</a> execution environment extending the <a>public Ethereum</a>
<a>EVM</a> op-code set [[!EVM-Opcodes]].
  </p>

  <p id="req-exec-030">
<b>[P] EXEC-030:</b> <a>Enterprise Ethereum clients</a> SHOULD support the ability to synchronize
their public state with the public state held by other <a>public Ethereum</a>
<a>nodes</a>.
  </p>

  <p id="req-exec-040">
    <b>[P] EXEC-040:</b> <a>Enterprise Ethereum clients</a> SHOULD support
    compilation, storage, and execution of <a>precompiled contracts</a>.
  </p>

  <p>
<a data-lt="TCS">Trusted Computing</a> ensures only authorized parties can
execute <a>smart contracts</a> on an execution environment available to a given
<a>Enterprise Ethereum blockchain</a>.
  </p>

  <p id="req-exec-050">
<b>[C] EXEC-050:</b> <a>Enterprise Ethereum clients</a> MAY support off-chain
<a data-lt="TCS">Trusted Computing</a>
  </p>

Multiple encryption techniques can be used to secure
<a data-lt="TCS">Trusted Computing</a> and <a>private state</a>.

  <p id="req-exec-060">
<b>[C] EXEC-060:</b> <a>Enterprise Ethereum clients</a> SHOULD provide configurable
encryption options for <a>Enterprise Ethereum blockchains</a>.
  </p>

      <section id="sec-finality">

      <h4>Finality</h4>

  <p>
<dfn data-lt="final|finalized">Finality</dfn></td> occurs when a
<a>transaction</a> is definitively part of the blockchain and cannot be removed.
A <a>transaction</a> reaches finality after some event defined for the relevant
blockchain occurs. For example, an elapsed amount of time or a specific number
of blocks added.
  </p>

  <p id="req-finl-010">
<b>[P] FINL-010:</b> When a deterministic <a>consensus algorithm</a> is used,
<a>Enterprise Ethereum clients</a> SHOULD treat <a>transactions</a> as <a>final</a>
after a defined interval or event. For example, after a defined time period has elapsed,
or after a defined number of blocks were created since the <a>transaction</a> was included in a block.
  </p>

      </section>

    </section>

    <section id="sec-consensus-sublayer">

    <h3>Consensus Sublayer</h3>

A common <a>consensus algorithm</a> implemented by all <a>clients</a> is
required to ensure interoperability between <a>clients</a>.

[[Byzantine-Fault-Tolerant]] <a>consensus algorithms</a> ensure a certain
proportion of malfunctioning <a>nodes</a> performing voting, block-making, or
validation roles do not pose a critical risk to the blockchain. This makes them an
excellent choice for many blockchains. The Technical Specification Working Group are
[considering](https://github.com/entethalliance/enhanced-bft) existing and new
Byzantine-Fault-Tolerant <a>consensus algorithms</a>, primarily those related to IBFT
[[EIP-650]], with the goal of adopting the outcomes of that work as a required
<a>consensus algorithm</a> as soon as possible.

  <p id="req-cons-030">
<b>[P] CONS-030:</b> One or more <a>consensus algorithms</a> SHOULD allow
operations as part of an <a>Enterprise Ethereum blockchain</a>.
  </p>

  <p id="req-cons-050">
<b>[P] CONS-050:</b> <a>Enterprise Ethereum clients</a> MAY implement multiple
<a>consensus algorithms</a> and use them on <a>sidechain</a> networks.
  </p>

  <p>
A <dfn data-lt="sidechains">sidechain</dfn> is a separate <a>Ethereum</a>
blockchain operating on the <a>Enterprise Ethereum blockchain</a>'s <a>nodes</a>. A sidechain
can be public or private and can also operate on a <a>consortium network</a>.
  </p>

  <p id="req-cons-093">
<b>[P] CONS-093:</b>  <a>Enterprise Ethereum clients</a> MUST support the "Clique" Proof of
Authority consensus algorithm. [[EIP-225]]
  </p>

  <p id="req-cons-110">
<b>[P] CONS-110:</b> <a>Enterprise Ethereum clients</a> MUST provide the ability
to specify the <a>consensus algorithms</a>, through <a>network configuration</a>,
to be used for each public blockchain, private blockchain, and <a>sidechain</a> in use.
  </p>

    </section>

  </section>

  <section id="sec-network-layer-main">

  <h2>Network Layer</h2>

The Network layer consists of an implementation of a peer-to-peer networking
protocol allowing <a>nodes</a> to communicate with each other.
For example, the <dfn>DEVp2p</dfn> protocol, which defines messaging between
<a>nodes</a> to establish and maintain a communications channel for use by
higher layer protocols.

Additional <a>organizational</a> peer-to-peer protocols will be formalized over
time to provide the communications needed to supplement higher levels of the
stack.
    <section id="sec-network-protocol-sublayer">

    <h3>Network Protocol Sublayer</h3>

Network protocols define how <a>nodes</a> communicate with each other.

  <p id="req-prot-010">
<b>[P] PROT-010:</b> <a>Nodes</a> MUST be identified and advertised using the
<a>Ethereum</a> enode URL format [[!enode]].
  </p>

  <p id="req-prot-015">
<b>[P] PROT-015:</b> <a>Enterprise Ethereum clients</a> MUST implement the <a>DEVp2p</a>
Node Discovery protocol [[!DEVp2p-Node-Discovery]].
  </p>

  <p>
The [[Ethereum-Wire-Protocol]] defines higher layer protocols, known as
<dfn>capability protocols</dfn>, for messaging between <a>nodes</a> to
exchange status, including block and <a>transaction</a> information.
[[Ethereum-Wire-Protocol]] messages are sent and received over an already
established <a>DEVp2p</a> connection between <a>nodes</a>.
  </p>

  <p id="req-prot-020">
<b>[P] PROT-020:</b> <a>Enterprise Ethereum clients</a> MUST use the <a>DEVp2p</a>
Wire Protocol [[!DEVp2p-Wire-Protocol]] for messaging between <a>nodes</a> to establish
and maintain a communications channel for use by <a>capability protocols</a>.
  </p>

  <p id="req-prot-040">
<b>[P] PROT-040:</b> <a>Enterprise Ethereum clients</a> MAY add new protocols
or extend existing <a>Ethereum</a> protocols.
  </p>

  <p id="req-prot-050">
<b>[P] PROT-050:</b> To minimize the number of point-to-point connections needed
between private <a>nodes</a>, some private <a>nodes</a> SHOULD be capable of
relaying <a>private transaction</a> data to multiple other private
<a>nodes</a>.
  </p>

  <aside class="example" title="Relaying Private Transaction Data">
    <p>
Multi-party private <a>smart contracts</a> and <a>transactions</a> do not
require direct connectivity between all parties because this is very impractical
in enterprise settings, especially when many parties are allowed to
<a>transact</a>. <a>Nodes</a> common to all parties (for example, voters or
blockmakers acting as bootnodes to all parties, and as backup or disaster
recovery <a>nodes</a>) are intended to function as gateways to synchronize
private <a>smart contracts</a> transparently. <a>Transactions</a> on private
<a>smart contracts</a> could then be transmitted to all participating parties in
the same way.
    </p>
  </aside>

  <p id="req-prot-060">
    <b>[P] PROT-060:</b> <a>Enterprise Ethereum clients</a> SHOULD implement the [[!Whisper-protocol]].
  </p>

    </section>

  </section>

  <section id="sec-anti-spam">

  <h2>Anti-spam</h2>

This section refers to mechanisms to prevent the <a>Enterprise Ethereum blockchain</a>
being degraded with a flood of intentional or unintentional <a>transactions</a>. This might be
realized through interfacing with an external security manager, as described in
Section <a href="#sec-enterprise-management-systems"></a>, or implemented by the
<a>client</a>, as described in the following requirement.

  <p id="req-spam-010">
<b>[P] SPAM-010:</b> <a>Enterprise Ethereum clients</a> SHOULD provide
effective anti-spam mechanisms so attacking <a>nodes</a> or <a>accounts</a>
(either malicious, buggy, or uncontrolled) can be quickly identified and
stopped.
  </p>

  <aside class="example" title="Anti-spam Mechanisms">
    <p>
Anti-spam mechanisms might include:
    </p>
      <ul>
        <li>
Stopping parties attempting to issue <a>transactions</a> above a threshold
volume.
        </li>
        <li>
Providing a mechanism to enforce a cost for <a>gas</a>, so <a>transacting</a>
parties have to acquire and pay for (or destruct) private ether to
<a>transact</a>.
        </li>
        <li>
Having a dynamic cost of <a>gas</a> based on activity intensity.
        </li>
      </ul>
  </aside>

  </section>

  <section id="sec-cross-client-compatibility">

  <h2>Cross-client Compatibility</h2>

Cross-client compatibility refers to the ability of an <a>Enterprise Ethereum blockchain</a>
to operate with different <a>clients</a>.

This Specification extends the capabilities and interfaces of
<a>public Ethereum</a>. The requirements relating to supporting and extending
the <a>public Ethereum</a> opcode set are outlined in Section
<a href="#sec-execution-sublayer"></a>.

  <p id="req-xcli-005">
<b>[P] XCLI-005:</b> Features of <a>public Ethereum</a> implemented in
<a>Enterprise Ethereum clients</a> MUST be compatible with the Constantinople
<a>hard fork</a> of <a>Ethereum</a> [[!EIP-1013]], which occured on 28 February, 2019.
  </p>

  <p>
Future versions of this Specification are expected to align with newer versions
of <a>public Ethereum</a> as they are deployed.
  </p>

  <p id="req-xcli-020">
<b>[P] XCLI-020:</b> <a>Enterprise Ethereum clients</a> MAY extend the <a>public Ethereum</a> APIs.
To maintain compatibility, <a>Enterprise Ethereum clients</a> SHOULD ensure these new features are
a superset of the <a>public Ethereum</a> APIs.
  </p>

  <aside class="example" title="Extensions to the Public Ethereum API">
    <p>
Extensions to <a>public Ethereum</a> APIs could include peer-to-peer APIs, the
[[JSON-RPC-API]] over IPC, HTTP/HTTPS, or websockets.
    </p>
  </aside>

  <p id="req-xcli-030">
<b>[P] XCLI-030:</b> <a>Enterprise Ethereum clients</a> MUST implement the
<a>gas</a> mechanism specified in the [[!Ethereum-Yellow-Paper]].
  </p>

  <p id="req-xcli-040">
<b>[P] XCLI-040:</b> <a>Gas</a> price MAY be set to zero.
  </p>

  <p id="req-xcli-050">
<b>[P] XCLI-050:</b> <a>Enterprise Ethereum clients</a> MUST implement the eight
precompiled contracts defined in Appendix E of the [[!Ethereum-Yellow-Paper]]:
  </p>

- `ecrecover`
- `sha256hash`
- `ripemd160hash`
- `dataCopy`
- `bigModExp`
- `bn256Add`
- `bn256ScalarMul`
- `bn256Pairing`

  <div class="note">
    <p>
Sample [[implementation-code-in-Golang]], as part of the Go-Ethereum client is
available from the Go-Ethereum source repository [[geth-repo]]. Be aware this
code uses a combination of GPL3 and LGPL3 licenses
    </p>
  </div>

Cross-client compatibility extends to the different message encoding formats
used by <a>clients</a>.

  <p id="req-xcli-055">
<b>[P] XCLI-055:</b> <a>Enterprise Ethereum clients</a> MUST register precompiled contracts
following the mechanisms defined by [[!EIP-1352]]:
  </p>

	  <p id="req-xcli-060">
<b>[P] XCLI-060:</b> <a>Enterprise Ethereum clients</a> MUST support the
Contract Application Binary Interface ([[!ABI]]) for interacting with
<a>smart contracts</a>.
  </p>

  <p id="req-xcli-070">
<b>[P] XCLI-070:</b> <a>Enterprise Ethereum clients</a> MUST support Recursive
Length Prefix ([[!RLP]]) encoding for binary data.
  </p>

  </section>

  <section id="sec-synchronization-and-disaster-recovery" class="informative">

  <h2>Synchronization and Disaster Recovery</h2>

Synchronization and disaster recovery refers to how <a>nodes</a> in a blockchain
behave when connecting for the first time or reconnecting.

Various techniques can help do this efficiently. For an
<a>Enterprise Ethereum blockchain</a> with few copies, off-chain backup
information can be important to ensure the long-term existence of the
information stored. A common backup format helps increase <a>client</a>
interoperability.

  </section>

  <section id="sec-additional-information" class="appendix">

  <h2>Additional Information</h2>

    <section id="sec-definitions">

    <h3>Terms defined in this specification</h3>

    <div class="inside">
      <ul class="respec-dfn-list">
        <li>
          <a href="#dfn-authorizedusers">
            authorizedUser<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-capability-protocols">
            capability protocols<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-client-requirements">
            Client requirements<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-consensus">
            Consensus<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-consensus-algorithms">
            consensus algorithm<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-consortium-networks">
            consortium network<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-dapp">
            ÐApps<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-devp2p">
            DEVp2p<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-enterprise-ethereum">
            Enterprise Ethereum<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-enterprise-ethereum-blockchains">
            Enterprise Ethereum blockchains<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-enterprise-ethereum-clients">
            Enterprise Ethereum client<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-ethereum-accounts">
            Ethereum account<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-ethereum-json-rpc-api">
            Ethereum JSON-RPC API<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-ens">
            Ethereum Name Service<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-evm">
            Ethereum Virtual Machine<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-final">
            Finality<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-formal-verification">
            Formal verification<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-gas">
            Gas<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-genesis-block">
            genesis block<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-group">
            Groups<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-hard-fork-block">
            hard fork block<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-hard-forks">
            hard fork<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-inter-chain-mediator">
            inter-chain mediators<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-integration-library">
            Integration libraries<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-mainnet">
            Ethereum MainNet<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-membergroups">
            memberGroups<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-metadata">
            Metadata<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-network">
            network<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-configurable">
            Network Configuration<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-node-list">
            node list<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-nodes">
            node<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-offchain-compute-scaling">
            Off-chain (layer 2 compute) scaling<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-onchain-layer-1-scaling">
            On-chain (layer 1) scaling<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-onchain-layer-2-scaling">
            On-chain (layer 2) scaling<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-onchain-privacy">
            On-chain privacy mechanisms<!---0.529120%-->
          </a>
        </li><li>
          <a href="#dfn-oracles">
            oracle<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-organizations">
            organization<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-payload-data">
            Payload data<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-performance">
            Performance<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-permissioning-decider">
            permissioning decider<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-permissions">
            Permissioning<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-precompiled-contracts">
            precompiled contract<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-privacy">
            Privacy<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-private-state">
            Private State<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-private-transaction-manager">
            private transaction manager<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-protocol-requirements">
            Protocol requirements<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-ethereum">
            Public Ethereum<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-restricted-private-transactions">
            Restricted private transactions<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-role">
            Roles<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-sidechains">
            sidechain<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-smart-contract-language">
            Smart contract languages<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-smart-contract">
            Smart contracts<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-private-transactions">
            private transaction<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-transactions">
            transaction<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-trusted-computing">
            Off-chain trusted computing<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-unrestricted-private-transactions">
            Unrestricted private transactions<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-users">
            User<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-wallet">
            Wallets<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-zero-knowledge-proofs">
            zero-knowledge proof<!---0.529120%-->
          </a>
        </li><!---0.529120%-->
      </ul><!---0.529120%-->
    </div>
    </section>

    <section id="sec-summary-of-requirements">

    <h3>Summary of Requirements</h3>

This section summarizes all of the requirements in this Specification into one
section.

  <p>
<a href="#req-dapp-010">
<b>[C] DAPP-010:</b></a> <a data-lt="Dapp">ÐApps</a> MAY use the extensions to the
<a>Ethereum JSON-RPC API</a> defined in this Specification.
  </p>

  <p>
<a href="#req-smrt-030">
<b>[P] SMRT-030:</b></a> <a>Enterprise Ethereum clients</a> MUST support <a>smart contracts</a>
of at least 24,576 bytes in size.
  </p>

  <p>
<a href="#req-smrt-040">
<b>[P] SMRT-040:</b></a> <a>Enterprise Ethereum clients</a> MUST read and enforce a size limit for
<a>smart contracts</a> from the current <a>network configuration</a> (e.g. the <a>genesis block</a>).
  </p>

  <p>
<a href="#req-smrt-050">
<b>[P] SMRT-050:</b></a> If no contract size limit is specified in a
<a>genesis block</a> or subsequent <a>network configuration</a>, <a>Enterprise Ethereum clients</a>
MUST enforce a size limit on <a>smart contracts</a> of 24,576 bytes.
  </p>

  <p>
<a href="#req-node-010">
<b>[C] NODE-010:</b></a> <a>Enterprise Ethereum clients</a> MUST provide the ability
to specify at startup a list of static peer <a>nodes</a> to establish peer-to-peer connections with.
  </p>

  <p>
<a href="#req-node-020">
<b>[C] NODE-020:</b></a> <a>Enterprise Ethereum clients</a> MUST provide the ability to enable or
disable peer-to-peer <a>node</a> discovery.
  </p>

  <p>
<a href="#req-node-030">
<b>[P] NODE-030:</b></a> <a>Enterprise Ethereum clients</a> MUST provide the ability to specify a
whitelist of the <a>nodes</a> permitted to connect to a <a>node</a>.
  </p>

  <p>
<a href="#req-node-040">
<b>[P] NODE-040:</b></a> <a>Enterprise Ethereum clients</a> MAY provide the ability to specify a
blacklist of the <a>nodes</a> not permitted to connect to a <a>node</a>.
  </p>

  <p>
<a href="#req-node-050">
<b>[P] NODE-050:</b></a> It MUST be possible to specify the <a>node</a> whitelist
required by <a href="#req-node-030"><b>NODE-030</b></a> through a transaction into a <a>smart contract</a>.
  </p>

  <p>
<a href="#req-node-060">
<b>[P] NODE-060:</b></a> It MUST be possible to specify the <a>node</a> blacklist
allowed by <a href="#req-node-040"><b>NODE-040</b></a> (if implemented) through a transaction into a <a>smart contract</a>.
  </p>

  <p>
<a href="#req-node-080">
<b>[P] NODE-080:</b></a> NODE-080:</b> <a>Enterprise Ethereum clients</a> MUST provide the ability to specify <a>node</a> identities in a way aligned with the concept of <a>groups</a>.
  </p>

  <p>
<a href="#req-node-090">
<b>[P] NODE-090:</b></a> <a>Enterprise Ethereum clients</a> MUST document which metadata parameters
(if any) can affect <a>transaction</a> ordering, and what the effects are.
  </p>

  <p>
<a href="#req-part-010">
<b>[P] PART-010:</b></a> <a>Enterprise Ethereum clients</a> MUST provide the ability
to specify a whitelist of <a>accounts</a> that are permitted to transact with the blockchain.
  </p>

  <p>
<a href="#req-part-015">
<b>[P] PART-015:</b></a> <a>Enterprise Ethereum clients</a> MUST be able to verify that <a>accounts</a>
are present on the whitelist required by <a href="#req-part-010"><b>PART-010:</b></a>
when adding <a>transactions</a> from the <a>account</a> to a block,
and when verifying a received block containing <a>transactions</a> created by that <a>account</a>.
  </p>

  <p>
<a href="#req-part-020">
<b>[P] PART-020:</b></a> <a>Enterprise Ethereum clients</a> MAY provide the ability to specify a
blacklist of <a>accounts</a> that are not permitted to transact with the blockchain.
  </p>

  <p>
<a href="#req-part-025">
<b>[P] PART-025:</b></a> <a>Enterprise Ethereum clients</a> MUST be able to verify that <a>accounts</a>
are not present on the blacklist allowed by <a href="#req-part-020"><b>PART-020:</b></a> (if implemented)
when adding <a>transactions</a> from the <a>account</a> to a block,
and when verifying a received block containing <a>transactions</a> created by that <a>account</a>.
  </p>

  <p>
<a href="#req-part-030">
<b>[P] PART-030:</b></a> It MUST be possible to specify the <a>account</a>
whitelist required by <a href="#req-part-010"><b>PART-010:</b></a>
through a transaction into a <a>smart contract</a>.
  </p>

  <p>
<a href="#req-part-040">
<b>[P] PART-040:</b></a> It MUST be possible to specify the <a>account</a>
blacklist allowed by <a href="#req-part-020"><b>PART-020:</b></a> (if implemented)
through a <a>transaction</a> into a <a>smart contract</a>.
  </p>

  <p>
<a href="#req-part-050">
<b>[P] PART-050:</b></a> <a>Enterprise Ethereum clients</a> MUST provide a mechanism
to identify <a>organizations</a> that participate in the <a>Enterprise Ethereum blockchain</a>.
  </p>

  <p>
<a href="#req-part-055">
<b>[P] PART-055</b></a> <a>Enterprise Ethereum clients</a> MUST support anonymous <a>accounts</a>.
  </p>

  <p>
<a href="#req-part-060">
<b>[P] PART-060:</b></a> <a>Enterprise Ethereum clients</a> MUST provide the ability
to specify <a>accounts</a> in a way aligned with the concepts of <a>groups</a> and <a>roles</a>.
  </p>

  <p>
<a href="#req-part-070">
<b>[P] PART-070:</b></a> <a>Enterprise Ethereum clients</a> MUST be able
to authorize the types of <a>transactions</a> an <a>account</a> can submit,
providing separate <a>permissioning</a> for the ability to:
  </p>

    <ul>
      <li>
Deploy <a>smart contracts</a>.
      </li>
      <li>
Call functions that change the state of specified <a>smart contracts</a>.
      </li>
      <li>
Perform a value transfer to a specified <a>account</a>.
      </li>
    </ul>

  <p>
<a href="#req-perm-075">
<b>[C] PERM-075:</b></a> <a>Enterprise Ethereum clients</a> MUST allow <a>organizations</a>
to be nested to a minimum of at least 3 levels
(i.e. an <a>organization</a> containing an <a>organization</a> that contains another <a>organization</a>).
  </p>

  <p>
<a href="#req-perm-020">
<b>[C] PERM-020:</b></a> <a>Enterprise Ethereum clients</a> SHOULD provide the ability for
<a>network configuration</a> to be updated at run time without the need to restart.
  </p>

  <p>
<a href="#req-perm-040">
<b>[C] PERM-040:</b></a> <a>Enterprise Ethereum clients</a> MAY support local key management,
allowing <a>users</a> to secure their private keys.
  </p>

  <p>
<a href="#req-perm-050">
<b>[C] PERM-050:</b></a> <a>Enterprise Ethereum clients</a> MAY support secure interaction
with an external key management system for key generation and secure key storage.
  </p>

  <p>
<a href="#req-jrpc-010">
<b>[P] JRPC-010:</b></a> <a>Enterprise Ethereum clients</a> MUST provide support for the following
methods of the <a>Ethereum JSON-RPC API</a>:
  </p>

* `net_version`
* `net_peerCount`
* `net_listening`
* `eth_protocolVersion`
* `eth_syncing`
* `eth_coinbase`
* `eth_hashrate`
* `eth_gasPrice`
* `eth_accounts`
* `eth_blockNumber`
* `eth_getBalance`
* `eth_getStorageAt`
* `eth_getTransactionCount`
* `eth_getBlockTransactionCountByHash`
* `eth_getBlockTransactionCountByNumber`
* `eth_getCode`
* `eth_sendRawTransaction`
* `eth_call`
* `eth_estimateGas`
* `eth_getBlockByHash`
* `eth_getBlockByNumber`
* `eth_getTransactionByHash`
* `eth_getTransactionByBlockHashAndIndex`
* `eth_getTransactionByBlockNumberAndIndex`
* `eth_getTransactionReceipt`
* `eth_getUncleByBlockHashAndIndex`
* `eth_getUncleByBlockNumberAndIndex`
* `eth_getLogs`.

  <p>
<a href="#req-jrpc-007">
<b>[P] JRPC-007:</b></a> <a>Enterprise Ethereum clients</a> SHOULD implement
[[JSON-RPC-API]] methods to be backward compatible with the definitions given in
version 27e37ee of the <a>Ethereum JSON-RPC API</a> reference [[!JSON-RPC-API-v27e37ee]],
unless breaking changes have been made and widely implemented for the health of the ecosystem.
For example, to fix a major security or privacy problem.
  </p>

  <p>
<a href="#req-jrpc-015">
<b>[C] JRPC-015:</b></a> <a>Enterprise Ethereum clients</a> MUST provide the capability to accept
and respond to JSON-RPC method calls over a websocket interface.
  </p>

  <p>
<a href="#req-jrpc-040">
<b>[C] JRPC-040:</b></a> <a>Enterprise Ethereum clients</a> MUST provide an implementation of the
<code>debug_traceTransaction</code> method [[debug-traceTransaction]] from the
Go Ethereum Management API.
  </p>

  <p>
<a href="#req-jrpc-050">
<b>[C] JRPC-050:</b></a> <a>Enterprise Ethereum clients</a> MUST implement the [[!JSON-RPC-PUB-SUB]] API.
  </p>

  <p>
<a href="#req-jrpc-070">
<b>[P] JRPC-070:</b></a> <a>Enterprise Ethereum clients</a> implementing additional nonstandard
subscription types for the [[!JSON-RPC-PUB-SUB]] API MUST prefix their
subscription type names with a namespace prefix other than <code>eea_</code>.
  </p>

  <p>
<a href="#req-jrpc-080">
<b>[P] JRPC-080:</b></a> The [[JSON-RPC]] method name prefix <code>eea_</code> MUST
be reserved for future use for RPC methods specific to the EEA.
  </p>

  <p>
<a href="#req-jrpc-020">
<b>[P] JRPC-020:</b></a> <a>Enterprise Ethereum clients</a> MUST provide
one of the following sets of extensions to create <a>private transaction</a> types defined in
Section <a href="#sec-private-transactions"></a>:
  </p>

  <ul>
    <li>
<code>eea_sendTransactionAsync</code> and <code>eea_sendTransaction</code>, or
    </li>
    <li>
<code>eea_sendRawTransactionAsync</code> and <code>eea_sendRawTransaction</code>.
    </li>
  </ul>

  <p>
<a href="#req-jrpc-030">
<b>[P] JRPC-030:</b></a> The <code>eea_sendTransactionAsync</code>,
<code>eea_sendTransaction</code>, <code>eea_sendRawTransactionAsync</code>, and
<code>eea_sendRawTransaction</code> methods MUST respond with a [[JSON-RPC]]
error response when an unimplemented <a>private transaction</a> type is
requested. The error response MUST have the <var>code</var> <code>-50100</code> and the
<var>message</var> <code>Unimplemented private transaction type</code>.
  </p>

  <p>
<a href="#req-perm-200">
<b>[P] PERM-200:</b></a> <a>Enterprise Ethereum clients</a> MUST call the
<code>connectionAllowed</code> function, as specified in Section
<a href="#sec-node-permissioning-functions"></a>, to determine whether a connection
with another <a>node</a> is permitted, and any restrictions to be placed on
that connection.
  </p>

  <p>
<a href="#req-perm-210">
<b>[P] PERM-210:</b></a> When checking the response to
<code>connectionAllowed</code>, if any unknown permissioning bits are found to
be zero, <a>Enterprise Ethereum clients</a> MUST reject the connection.
  </p>

  <p>
<a href="#req-perm-220">
<b>[P] PERM-220:</b></a> On receipt of a <code>NodePermissionsUpdated</code>
event containing an 'addsRestrictions' property with value 'true',
<a>Enterprise Ethereum clients</a> MUST close any network connections
that are no longer permitted, and impose newly added restrictions on any
network connections that have had restrictions added.
  </p>

  <p>
<a href="#req-perm-230">
<b>[P] PERM-230:</b></a> On receipt of a <code>NodePermissionsUpdated</code>
event containing an 'addsRestrictions' property with value 'false',
<a>Enterprise Ethereum clients</a> MUST allow future actions that are now permitted.
  </p>

  <p>
<a href="#req-perm-240">
<b>[P] PERM-240:</b></a> When validating or mining a block, <a>Enterprise Ethereum clients</a> MUST
call the <code>transactionAllowed</code> function, as specified in
Section <a href="#sec-account-permissioning-function"></a>, with worldstate as
at the block's parent, to determine if a <a>transaction</a> is permitted in a block.
  </p>

  <p>
<a href="#req-orcl-010">
<b>[C] ORCL-010:</b></a> <a>Enterprise Ethereum clients</a> SHOULD provide
the ability to securely interact with <a>oracles</a> to send and receive
external off-chain information.
  </p>

  <p>
<a href="#req-priv-010">
<b>[P] PRIV-010:</b></a> <a>Enterprise Ethereum clients</a> MUST support <a>private transactions</a>
using either <a>restricted private transactions</a> or
<a>unrestricted private transactions</a>.
  </p>

When implementing <a>restricted private transactions</a>:

  <ul>
    <li>
<a href="#req-priv-020">
<b>[P] PRIV-020:</b></a> <a>Enterprise Ethereum clients</a> MUST encrypt
<a>payload data</a> when stored in <a>restricted private transactions</a>.
    </li>
    <li>
<a href="#req-priv-030">
<b>[P] PRIV-030:</b></a> <a>Enterprise Ethereum clients</a> MUST encrypt
<a>payload data</a> when in transit in <a>restricted private transactions</a>.
    </li>
    <li>
<a href="#req-priv-040">
<b>[P] PRIV-040:</b></a> <a>Enterprise Ethereum clients</a> MAY encrypt
<a>metadata</a> when stored in <a>restricted private transactions</a>.
    </li>
    <li>
<a href="#req-priv-050">
<b>[P] PRIV-050:</b></a> <a>Enterprise Ethereum clients</a> MAY encrypt
<a>metadata</a> when in transit in <a>restricted private transactions</a>.
    </li>
    <li>
<a href="#req-priv-060">
<b>[P] PRIV-060:</b></a> <a>Nodes</a> that relay a
<a>restricted private transaction</a> but are not party to that
<a>transaction</a>, MUST NOT store <a>payload data</a>.
    </li>
    <li>
<a href="#req-priv-070">
<b>[P] PRIV-070:</b></a> <a>Nodes</a> that relay a
<a>restricted private transaction</a> but are not party to that
<a>transaction</a> SHOULD NOT store the <a>metadata</a>.
    </li>
    <li>
<a href="#req-priv-080">
<b>[P] PRIV-080:</b></a> The implementation of the
<code>eea_sendTransactionAsync</code>, <code>eea_sendTransaction</code>,
<code>eea_sendRawTransactionAsync</code>, or <code>eea_sendRawTransaction</code>
methods (see Section <a href="#sec-extensions-json-rpc"></a>) with the
<code>restriction</code> parameter set to <code>restricted</code>, MUST result
in a <a>restricted private transaction</a>.
    </li>
  </ul>

When implementing <a>unrestricted private transactions</a>:

  <ul>
    <li>
<a href="#req-priv-090">
<b>[P] PRIV-090:</b></a> <a>Enterprise Ethereum clients</a> SHOULD encrypt
the recipient identity when stored in <a>unrestricted private transactions</a>.
    </li>
    <li>
<a href="#req-priv-100">
<b>[P] PRIV-100:</b></a> <a>Enterprise Ethereum clients</a> SHOULD encrypt
the sender identity when stored in <a>unrestricted private transactions</a>.
    </li>
    <li>
<a href="#req-priv-110">
<b>[P] PRIV-110:</b></a> <a>Enterprise Ethereum clients</a> SHOULD encrypt
the <a>payload data</a> when stored in <a>unrestricted private transactions</a>.
    </li>
    <li>
<a href="#req-priv-120">
<b>[P] PRIV-120:</b></a> <a>Enterprise Ethereum clients</a> MUST encrypt
<a>payload data</a> when in transit in <a>unrestricted private transactions</a>.
    </li>
    <li>
<a href="#req-priv-130">
<b>[P] PRIV-130:</b></a> <a>Enterprise Ethereum clients</a> MAY encrypt
<a>metadata</a> when stored in <a>unrestricted private transactions</a>.
    </li>
    <li>
<a href="#req-priv-140">
<b>[P] PRIV-140:</b></a> <a>Enterprise Ethereum clients</a> MAY encrypt
<a>metadata</a> when in transit in <a>unrestricted private transactions</a>.
    </li>
    <li>
<a href="#req-priv-150">
<b>[P] PRIV-150:</b></a> <a>Nodes</a> that relay an
<a>unrestricted private transaction</a> but are not party to that
<a>transaction</a> MAY store <a>payload data</a>.
    </li>
    <li>
<a href="#req-priv-160">
<b>[P] PRIV-160:</b></a> <a>Nodes</a> that relay an
<a>unrestricted private transaction</a> but are not party to that
<a>transaction</a>, MAY store the <a>metadata</a>.
    </li>
    <li>
<a href="#req-priv-170">
<b>[P] PRIV-170:</b></a> The implementation of the
<code>eea_sendTransactionAsync</code>, <code>eea_sendTransaction</code>,
<code>eea_sendRawTransactionAsync</code>, or <code>eea_sendRawTransaction</code>
methods (see Section <a href="#sec-extensions-json-rpc"></a>) with the
<code>restriction</code> parameter set to <code>unrestricted</code> MUST result
in an <a>unrestricted private transaction</a>.
    </li>
    <li>
<a href="#req-priv-210">
<b>[P] PRIV-210:</b></a> <a>Enterprise Ethereum clients</a>' implementations of
<a>unrestricted private transactions</a> MUST provide the ability for <a>nodes</a>
to achieve global <a>consensus</a>.
    </li>
  </ul>

  <p>
<a href="#req-priv-180">
<b>[P] PRIV-180:</b></a> <a>Enterprise Ethereum clients</a> SHOULD be able to extend the set of
parties to a <a>private transaction</a> (or forward the <a>private transaction</a> in some way).
  </p>

  <p>
<a href="#req-priv-190">
<b>[P] PRIV-190:</b></a> <a>Enterprise Ethereum clients</a> SHOULD provide the ability for
<a>nodes</a> to achieve <a>consensus</a> on their mutually <a>private transactions</a>.
  </p>

  <p>
<a href="#req-stor-030">
<b>[C] STOR-030:</b></a> <a>Enterprise Ethereum clients</a> providing support for multiple blockchains
(for example, more than one <a>Enterprise Ethereum blockchain</a>, or a public network) MUST
store data related to restricted <a>private transactions</a> for those blockchains
in <a>private state</a> dedicated to the relevant blockchain.
  </p>

  <p>
<a href="#req-stor-040">
<b>[P] STOR-040:</b></a> <a>Enterprise Ethereum clients</a> SHOULD permit a
<a>smart contract</a> operating on <a>private state</a> to access <a>private state</a>
created by other <a>smart contracts</a> involving the same parties to the <a>transaction</a>.
  </p>

  <p>
<a href="#req-stor-050">
<b>[P] STOR-050:</b></a> <a>Enterprise Ethereum clients</a> MUST NOT permit
<a>smart contract</a> operating on <a>private state</a> to access <a>private state</a>
created by other <a>smart contracts</a> involving different parties to the <a>transaction</a>.
  </p>

  <p>
<a href="#req-stor-070">
<b>[P] STOR-070:</b></a> If an <a>Enterprise Ethereum client</a> stores <a>private state</a>
persistently, it SHOULD protect the data using an Authenticated Encryption with
Additional Data (AEAD) algorithm, such as one described in [[RFC5116]].
  </p>

  <p>
<a href="#req-exec-010">
<b>[P] EXEC-010:</b></a> <a>Enterprise Ethereum clients</a> MUST provide a
<a>smart contract</a> execution environment implementing the
<a>public Ethereum</a> <a>EVM</a> op-code set [[!EVM-Opcodes]].
  </p>

  <p>
<a href="#req-exec-020">
<b>[P] EXEC-020:</b></a> <a>Enterprise Ethereum clients</a> MAY provide a
<a>smart contract</a> execution environment extending the <a>public Ethereum</a>
<a>EVM</a> op-code set [[!EVM-Opcodes]].
  </p>

  <p>
<a href="#req-exec-030">
<b>[P] EXEC-030:</b></a> <a>Enterprise Ethereum clients</a> SHOULD support the ability to synchronize
their public state with the public state held by other <a>public Ethereum</a> <a>nodes</a>.
  </p>

  <p>
<a href="#req-exec-040">
<b>[P] EXEC-040:</b></a> <a>Enterprise Ethereum clients</a> SHOULD support
compilation, storage, and execution of <a>precompiled contracts</a>.
  </p>

  <p>
<a href="#req-exec-050">
<b>[C] EXEC-050:</b></a> <a>Enterprise Ethereum clients</a> MAY support off-chain
<a data-lt="TCS">Trusted Computing</a>
  </p>

  <p>
<a href="#req-exec-060">
<b>[C] EXEC-060:</b></a> <a>Enterprise Ethereum clients</a> SHOULD provide configurable
encryption options for <a>Enterprise Ethereum blockchains</a>.
  </p>

  <p>
<a href="#req-finl-010">
<b>[P] FINL-010:</b></a> When a deterministic <a>consensus algorithm</a> is used,
<a>Enterprise Ethereum clients</a> SHOULD treat <a>transactions</a> as <a>final</a>
after a defined interval or event. For example, after a defined time period has elapsed,
or after a defined number of blocks were created since the <a>transaction</a> was included in a block.
  </p>

  <p>
<a href="#req-cons-030">
<b>[P] CONS-030:</b></a> One or more <a>consensus algorithms</a> SHOULD allow
operations as part of an <a>Enterprise Ethereum blockchain</a>.
  </p>

  <p>
<a href="#req-cons-050">
<b>[P] CONS-050:</b></a> <a>Enterprise Ethereum clients</a> MAY implement multiple
<a>consensus algorithms</a> and use them on <a>sidechain</a> networks.
  </p>

  <p>
<a href="#req-cons-093">
<b>[P] CONS-093:</b></a>  <a>Enterprise Ethereum clients</a> MUST support the "Clique" Proof of
Authority consensus algorithm. [[EIP-225]]
  </p>

  <p>
<a href="#req-cons-110">
<b>[P] CONS-110:</b></a> <a>Enterprise Ethereum clients</a> MUST provide the ability
to specify the <a>consensus algorithms</a>, through <a>network configuration</a>,
to be used for each public blockchain, private blockchain, and <a>sidechain</a> in use.
  </p>

  <p>
<a href="#req-prot-010">
<b>[P] PROT-010:</b></a> <a>Nodes</a> MUST be identified and advertised using the
<a>Ethereum</a> enode URL format [[!enode]].
  </p>

  <p>
<a href="#req-prot-015">
<b>[P] PROT-015:</b></a> <a>Enterprise Ethereum clients</a> MUST implement the <a>DEVp2p</a>
Node Discovery protocol [[!DEVp2p-Node-Discovery]].
  </p>

  <p>
<a href="#req-prot-020">
<b>[P] PROT-020:</b></a> <a>Enterprise Ethereum clients</a> MUST use the <a>DEVp2p</a>
Wire Protocol [[!DEVp2p-Wire-Protocol]] for messaging between <a>nodes</a> to establish
and maintain a communications channel for use by <a>capability protocols</a>.
  </p>

  <p>
<a href="#req-prot-040">
<b>[P] PROT-040:</b></a> <a>Enterprise Ethereum clients</a> MAY add new protocols
or extend existing <a>Ethereum</a> protocols.
  </p>

  <p>
<a href="#req-prot-050">
<b>[P] PROT-050:</b></a> To minimize the number of point-to-point connections needed between private <a>nodes</a>, some private <a>nodes</a> SHOULD be capable of
relaying <a>private transaction</a> data to multiple other private
<a>nodes</a>.
  </p>

  <p>
<a href="#req-prot-060">
<b>[P] PROT-060:</b></a> <a>Enterprise Ethereum clients</a> SHOULD implement the [[!Whisper-protocol]].
  </p>

  <p>
<a href="#req-spam-010">
<b>[P] SPAM-010:</b></a> <a>Enterprise Ethereum clients</a> SHOULD provide
effective anti-spam mechanisms so attacking <a>nodes</a> or <a>accounts</a>
(either malicious, buggy, or uncontrolled) can be quickly identified and
stopped.
  </p>

  <p>
<a href="#req-xcli-005">
<b>[P] XCLI-005:</b></a> Features of <a>public Ethereum</a> implemented in
<a>Enterprise Ethereum clients</a> MUST be compatible with the Constantinople
<a>hard fork</a> of <a>Ethereum</a> [[!EIP-1013]], which occured on 28 February, 2019.
  </p>

  <p>
<a href="#req-xcli-020">
<b>[P] XCLI-020:</b></a> <a>Enterprise Ethereum clients</a> MAY extend the <a>public Ethereum</a> APIs.
To maintain compatibility, <a>Enterprise Ethereum clients</a> SHOULD ensure these new features are
a superset of the <a>public Ethereum</a> APIs.
  </p>

  <p>
<a href="#req-xcli-030">
<b>[P] XCLI-030:</b></a> <a>Enterprise Ethereum clients</a> MUST implement the
<a>Gas</a> mechanism specified in the [[!Ethereum-Yellow-Paper]].
  </p>

  <p>
<a href="#req-xcli-040">
<b>[P] XCLI-040:</b></a> <a>Gas</a> price MAY be set to zero.
  </p>

  <p>
<a href="#req-xcli-050">
<b>[P] XCLI-050:</b></a> <a>Enterprise Ethereum clients</a> MUST implement the eight precompiled contracts defined in Appendix E of the [[!Ethereum-Yellow-Paper]]:
  </p>

* `ecrecover`
* `sha256hash`
* `ripemd160hash`
* `dataCopy`
* `bigModExp`
* `bn256Add`
* `bn256ScalarMul`
* `bn256Pairing`

  <p>
<a href="req-xcli-055">
	<b>[P] XCLI-055:</b></a> <a>Enterprise Ethereum clients</a> MUST register precompiled contracts
following the mechanisms defined by [[!EIP-1352]]:
  </p>

  <p>
<a href="#req-xcli-060">
<b>[P] XCLI-060:</b></a> <a>Enterprise Ethereum clients</a> MUST support the
Contract Application Binary Interface ([[!ABI]]) for interacting with
<a>smart contracts</a>.
  </p>

  <p>
<a href="#req-xcli-070">
<b>[P] XCLI-070:</b></a> <a>Enterprise Ethereum clients</a> MUST support Recursive
Length Prefix ([[!RLP]]) encoding for binary data.
  </p>

    </section>

    <section id="sec-acknowledgments">

    <h3>Acknowledgments</h3>

The EEA acknowledges and thanks the many people who contributed to the
development of this version of the specification. Please advise us of any errors
or omissions.

This version builds on the work of all who contributed to
[previous versions of the Enterprise Ethereum Client Specification](https://entethalliance.org/resources/),
whom we hope are all acknowledged in those documents. We apologize to anyone
whose name was left off the list. Please advise us at
[https://entethalliance.org/contact/](https://entethalliance.org/contact/) of
any errors or omissions.

We would also like to thank former editors David Hyland-Wood (version 1) and
Daniel Burnett (version 2), and former EEA Technical Director, the late and
missed Clifton Barber, for their work on previous versions of this
specification.

Enterprise Ethereum is built on top of Ethereum, and we are grateful to the entire
community who develops Ethereum, for their work and their ongoing collaboration
to helps us maintain as much compatibility as possible with the Ethereum ecosystem.
    </section>

    <section id="sec-changes">

    <h3>Changes</h3>

Full details of all changes since the version 1.0 release of this Specification
are available in the
[GitHub repository for this Specification](https://github.com/entethalliance/client-spec).

This section outlines substantive changes made to the specification since
version 3:

- [Pull Request 543](https://github.com/entethelliance/client-spec/pull/543):
Add <a href="req-xcli-055"><b>[P] XCLI-055:</b></a> requiring precompiled contracts to be registered according to [[EIP-1352]].
- [Pull Request 538](https://github.com/entethelliance/client-spec/pull/538):
Removed experimental `eea_clientCapabilities` RPC method.
- [Pull Request 534](https://github.com/entethelliance/client-spec/pull/534):
Update privacy requirements to require they "encrypt" rather than "support encryption of" private transaction data

Note that similar sections in Version 2 and <a href="https://entethalliance.org/wp-content/uploads/2019/05/EEA_Enterprise_Ethereum_Client_Specification_V3.pdf">version 3</a> describe the changes made to each version.

    </section>

  </section>

<script class='remove'>
async function loadSolidity() {    //this is the function you call in 'preProcess'
    const worker = await new Promise(resolve => {
      require(["core/worker"], ({ worker }) => resolve(worker));
    });
    const action = "highlight-load-lang";
    const langURL =
      "https://rawgit.com/pospi/highlightjs-solidity/master/solidity.js";
    const propName = "hljsDefineSolidity";
    const lang = "solidity";     // this is the class you use to identify the language
    worker.postMessage({ action, langURL, propName, lang });
    return new Promise(resolve => {
      worker.addEventListener("message", function listener({ data }) {
        const { action: responseAction, lang: responseLang } = data;
        if (responseAction === action && responseLang === lang) {
          worker.removeEventListener("message", listener);
          resolve();
        }
      });
    });
  }


function cleanUp () {
  document.querySelector('h2').removeChild(document.querySelector('h2').firstChild);
  document.head.removeChild(document.querySelectorAll('link[rel=stylesheet]')[1]);
  document.head.removeChild(document.querySelector('link[rel=canonical]'));

  document.querySelector('p.copyright').innerHTML="Copyright © 2018-2019 <a href='https://entethalliance.org/'>Enterprise Ethereum Alliance</a>."

  var linksList = document.querySelector('div.head > dl');
  linksList.removeChild(document.querySelectorAll('div.head dt')[5]);
  linksList.removeChild(document.querySelectorAll('div.head dt')[1]);
  linksList.removeChild(document.querySelectorAll('div.head dt')[0]);
  linksList.removeChild(document.querySelectorAll('div.head dd')[12]);
  linksList.removeChild(document.querySelectorAll('div.head dd')[11]);
  linksList.removeChild(document.querySelectorAll('div.head dd')[10]);
  linksList.removeChild(document.querySelectorAll('div.head dd')[9]);
  linksList.removeChild(document.querySelectorAll('div.head dd')[1]);
  linksList.removeChild(document.querySelectorAll('div.head dd')[0]);

  var theA = document.querySelector('[href=dummycontrib]');
  theA.outerHTML = theA.innerHTML;


  //
  // This is ugly but works unless ReSpec tracks a serious change to W3C boilerplate
  //

    var statusSection = document.querySelector('section#sotd');
    var statusPs = document.querySelectorAll('#sotd > p').length;
    statusSection.removeChild(document.querySelectorAll('#sotd > p')[(statusPs-1)]);
    statusSection.removeChild(document.querySelectorAll('#sotd > p')[(statusPs-2)]);
    statusSection.removeChild(document.querySelectorAll('#sotd > p')[(statusPs-3)]);
    statusSection.removeChild(document.querySelectorAll('#sotd > p')[(statusPs-5)]);
    statusSection.removeChild(document.querySelectorAll('#sotd > p')[0]);

}

var respecConfig = {
  preProcess: [loadSolidity],
  format: "markdown",
  specStatus: "ED",
  edDraftURI: "https://entethalliance.github.io/client-spec/spec.html",
  postProcess: [cleanUp],
  editors: [{
    name: "Robert Coote",
    company: "PegaSys",
    mailto: "robert.coote@consensys.net",
  },{
    name: "Chaals Nevile",
    company: "Enterprise Ethereum Alliance",
    mailto: "chaals@entethalliance.org",
  },{
    name: "Grant Noble",
    company: "PegaSys",
    mailto: "grant.noble@consensys.net",
  },{
    name: "George Polzer",
    company: "Everymans.ai",
    mailto: "gpolzer@everymans.ai",
  }],
  formerEditors: [{
    name: "Daniel Burnett",
    company: "PegaSys",
    companyURL: "https://pegasys.tech"
  },{
    name: "David Hyland-Wood",
    company: "PegaSys",
    companyURL: "https://pegasys.tech"
  }],
  github: "https://github.com/EntEthAlliance/client-spec",
  shortName: "EEASpec",
  copyrightStart: 2019,
  logos: [{
    src: './images/eea_logo.svg',
    href: "https://entethalliance.org",
    alt: " ",
    width: 180,
    height: 90,
    id: 'eea-logo',
  }],
  otherLinks: [{
    key: "Contributors to this version",
    data: [{
      value: "Janie Baños (Dekra), Imran Bashir (JP Morgan Chase), \
          Meredith Baxter (PegaSys), \
	  Mark Bruening (BakerHostetler), Zak Cole (Whiteblock), Sara Feenan (Clearmatics),\
          Ivaylo Kirilov (Web3Labs), \
	  Maya Konaka (Blockapps), Kieren James-Lubin (Blockapps), Chris McKay (PegaSys),\
          Boris Mann (SPADE), Arash Mahboubi (PegaSys), George Ornbo (Clearmatics), \
          Brianna Rich (EEA), Lior Saar (BlockApps), Felix Shnir (JP Morgan Chase), \
          Przemek Siemion (Banco Santander), Conor Svensson (Web3Labs), \
          Clark Thompson (ConsenSys), \
          Jim Zhang (ConsenSys), Weijia Zhang (Wanchain)",
      href:"dummycontrib"
    }]
  }],
  localBiblio: {
    "ABI": {
      title: "Contract ABI Specification",
      href: "https://solidity.readthedocs.io/en/develop/abi-spec.html",
      publisher: "Ethereum Foundation"
    },
    "Byzantine-Fault-Tolerant": {
      title: "Byzantine Fault Tolerant",
      href: "https://en.wikipedia.org/wiki/Byzantine_fault_tolerance"
    },
    "DEVp2p-Node-Discovery": {
      title: "Node Discovery Protocol",
      href: "https://github.com/ethereum/devp2p/blob/master/rlpx.md"
    },
    "DEVp2p-Wire-Protocol": {
      title: "ÐΞVp2p Wire Protocol",
      href: "https://github.com/ethereum/devp2p/blob/master/caps/eth.md"
    },
    "DIF": {
      title: "Decentralized Identity Foundation",
      href: "http://identity.foundation/"
    },
    "EEA-OC": {
      title: "EEA Off-Chain Trusted Compute Specification V0.5",
      href: "http://entethalliance.org/wp-content/uploads/2018/10/EEA_Off_Chain_Trusted_Compute_Specification_V0_5.pdf",
      publisher: "Enterprise Ethereum Alliance, Inc."
    },
    "EIP-225": {
      title: "Clique proof-of-authority consensus protocol",
      href: "https://eips.ethereum.org/EIPS/eip-225",
      publisher: "Ethereum Foundation"
    },
    "EIP-648": {
      title: "Easy Parallelizability",
      href: "https://github.com/ethereum/EIPs/issues/648",
      publisher: "Ethereum Foundation"
    },
    "EIP-650": {
      title: "Istanbul Byzantine Fault Tolerance",
      href: "https://github.com/ethereum/EIPs/issues/650",
      publisher: "Ethereum Foundation"
    },
    "EIP-1013": {
      title: "Hardfork Meta: Constantinople",
      href: "https://eips.ethereum.org/EIPS/eip-1013",
      publisher: "Ethereum Foundation"
    },
    "EIP-1352": {
      title: "Specify restricted address range for precompiles/system contracts",
      href: "https://eips.ethereum.org/EIPS/eip-1352",
      publisher: "Ethereum Foundation"
    },
    "EIPs": {
      title: "Ethereum Improvement Proposals",
      href: "https://eips.ethereum.org/",
      publisher: "Ethereum Foundation"
    },
    "enode": {
      title: "Ethereum enode URL format",
      href: "https://github.com/ethereum/wiki/wiki/enode-url-format",
      publisher: "Ethereum Foundation"
    },
    "ERC-20": {
      title: "Ethereum Improvement Proposal 20 - Standard Interface for Tokens",
      href: "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md",
      publisher: "Ethereum Foundation"
    },
    "ERC-223": {
      title: "Ethereum Improvement Proposal 223 - Token Standard",
      href: "https://github.com/ethereum/EIPs/issues/223",
      publisher: "Ethereum Foundation"
    },
    "ERC-621": {
      title: "Ethereum Improvement Proposal 621 - Token Standard Extension for Increasing & Decreasing Supply",
      href: "https://github.com/ethereum/EIPs/pull/621",
      publisher: "Ethereum Foundation"
    },
    "ERC-721": {
      title: "Ethereum Improvement Proposal 721 - Non-fungible Token Standard",
      href: "https://github.com/ethereum/eips/issues/721",
      publisher: "Ethereum Foundation"
    },
    "ERC-827": {
      title: "Ethereum Improvement Proposal 827 - Extension to ERC-20",
      href: "https://github.com/ethereum/EIPs/issues/827",
      publisher: "Ethereum Foundation"
    },
    "Ethereum": {
      title: "Ethereum Foundation",
      href: "https://www.ethereum.org/foundation"
    },
    "Ethereum-Foundation": {
      aliasOf: "Ethereum"
    },
    "Ethereum-Wire-Protocol": {
      title: "Ethereum Wire Protocol",
      href: "https://github.com/ethereum/wiki/wiki/Ethereum-Wire-Protocol"
    },
    "Ethereum-Yellow-Paper": {
      title: "Ethereum: A Secure Decentralized Generalized Transaction Ledger",
      href: "https://ethereum.github.io/yellowpaper/paper.pdf",
      publisher: "Dr. Gavin Wood"
    },
    "EVM-Opcodes": {
      title: "Ethereum Virtual Machine (EVM) Opcodes and Instruction Reference",
      href: "https://github.com/trailofbits/evm-opcodes"
    },
    "eWASM": {
      title: "Ethereum-flavored WebAssembly",
      href: "https://github.com/ewasm/design"
    },
    "GDPR": {
      title: "European Union General Data Protection Regulation",
      href: "https://eur-lex.europa.eu/legal-content/EN/TXT/?qid=1528874672298&uri=CELEX%3A32016R0679",
      publisher: "European Union"
    },
    "debug-traceTransaction":{
      title: "debug_traceTransaction",
      href: "https://github.com/ethereum/go-ethereum/wiki/Management-APIs"
    },
	"geth-repo":{
      title: "Go-Ethereum",
      href: "https://github.com/ethereum/go-ethereum/"
    },
	"implementation-code-in-Golang":{
      title: "implementation code in Golang",
      href: "https://github.com/ethereum/go-ethereum/blob/master/core/vm/contracts.go#L50-L360"
    },
    "IBFT-2.0": {
      title: "IBFT 2.0 Specification",
      href: "https://arxiv.org/abs/1901.07160",
      publisher: "PegaSys (ConsenSys)"
    },
    "JSON-RPC": {
      title: "JavaScript Object Notation - Remote Procedure Call",
      href: "http://www.jsonrpc.org/specification",
      publisher: "JSON-RPC Working Group"
    },
    "JSON-RPC-API": {
      title: "Ethereum JSON-RPC API",
      href: "https://github.com/ethereum/wiki/wiki/JSON-RPC",
      publisher: "Ethereum Foundation"
    },
    "JSON-RPC-API-v27e37ee": {
      title: "Ethereum JSON-RPC API",
      href: "https://github.com/ethereum/wiki/wiki/JSON-RPC/27e37ee31ca29565fd8542ced0814fefc37a94fb",
      publisher: "Ethereum Foundation"
    },
    "JSON-RPC-PUB-SUB": {
      title: "RPC PUB-SUB",
      href: "https://github.com/ethereum/go-ethereum/wiki/RPC-PUB-SUB",
      publisher: "Ethereum Foundation"
    },
    "Layer2-Scaling-Solutions": {
      title: "Making Sense of Ethereum's Layer 2 Scaling Solutions: State Channels, Plasma, and Truebit",
      href: "https://medium.com/l4-media/making-sense-of-ethereums-layer-2-scaling-solutions-state-channels-plasma-and-truebit-22cb40dcc2f4",
      publisher: "Josh Stark",
      date: "February 2018"
    },
    "LLL": {
      title: "LLL Introduction",
      href: "http://lll-docs.readthedocs.io/en/latest/lll_introduction.html",
      publisher: "Ben Edgington",
      date: "2017"
    },
    "Nethereum": {
      title: "Nethereum .NET Integration Library",
      href: "https://nethereum.com",
      publisher: "Nethereum Open Source Community"
    },
    "Plasma": {
      title: "Plasma: Scalable Autonomous Smart Contracts",
      href: "https://plasma.io/plasma.pdf",
      publisher: "Joseph Poon and Vitalik Buterin",
      date: "August 2017"
    },
    "PoET": {
      title: "Proof of Elapsed Time 1.0 Specification",
      href: "https://sawtooth.hyperledger.org/docs/core/releases/1.0/architecture/poet.html#",
      publisher: "Intel Corporation",
      date: "2015-2017"
    },
    "protocol-buffers": {
      title: "A language-neutral, platform-neutral extensible mechanism for serializing structured data",
      href: "https://developers.google.com/protocol-buffers/",
      publisher: "Google Developers"
    },
    "PSD2": {
      title: "European Union Personal Service Directive",
      href: "https://ec.europa.eu/info/law/payment-services-psd-2-directive-eu-2015-2366_en",
      publisher: "European Union"
    },
    "RAFT": {
      title: "Raft-based Consensus for Ethereum/Quorum",
      href: "https://github.com/jpmorganchase/quorum/blob/master/raft/doc.md",
      publisher: "J.P. Morgan"
    },
    "Remix": {
      title: "Ethereum Tools for the Web",
      href: "https://github.com/ethereum/remix",
      publisher: "Ethereum Foundation"
    },
    "RLP": {
      title: "Recursive Length Prefix",
      href: "https://github.com/ethereum/wiki/wiki/RLP",
      publisher: "Ethereum Foundation"
    },
    "sharding": {
      title: "Sharding FAQs",
      href: "https://github.com/ethereum/wiki/wiki/Sharding-FAQs",
      publisher: "Ethereum Foundation"
    },
    "Solidity": {
      title: "The Solidity Contract-Oriented Programming Language",
      href: "https://github.com/ethereum/solidity",
      publisher: "Ethereum Foundation"
    },
    "state-channels": {
      title: "Counterfactual: Generalized State Channels",
      href: "https://counterfactual.com/statechannels"
    },
    "Truffle": {
      title: "Ethereum Development Framework",
      href: "https://truffleframework.com/",
      publisher: "ConsenSys"
    },
    "web3j": {
      title: "web3j Lightweight Ethereum Java and Android Integration Library",
      href: "https://web3j.io",
      publisher: "Conor Svensson"
    },
    "web3.js": {
      title: "Ethereum JavaScript API",
      href: "https://github.com/ethereum/web3.js",
      publisher: "Ethereum Foundation"
    },
    "Whisper-protocol": {
      title: "Whisper",
      href: "https://github.com/ethereum/wiki/wiki/Whisper",
      publisher: "Ethereum Foundation"
    },
    "ZK-STARKS": {
      title: "Scalable, transparent, and post-quantum secure computational integrity",
      href: "https://eprint.iacr.org/2018/046.pdf",
      publisher: "Cryptology ePrint Archive",
      date: "2018-03-16"
    }
  }
};
</script>

</body>

</html>
