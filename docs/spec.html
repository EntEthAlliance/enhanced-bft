<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>Enterprise Ethereum Enhanced BFT Specification v1</title>

<script
src='https://www.w3.org/Tools/respec/respec-w3c-common'
class='remove'></script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<style>
table, th, td {
    border: 1px solid black;
    border-collapse: collapse;
}
th, td {
    padding: 5px;
}
code {
    font-family: georgia, serif;
	color: black;
}
</style>

</head>

<body>

<section id='abstract'>

This document, the Enterprise Ethereum Alliance Enhanced BFT Specification,
defines enhancements to the BFT algorithm, including liveness and security.

</section>

<section id='sotd'>

*This section describes the status of this document at the time of its
publication. Newer documents might supersede this document.*

This is an editors' draft of the Enterprise Ethereum Alliance Enhanced BFT
Specification version 1.

</section>

  <section id="sec-introduction" class="informative">

  <h2>Introduction</h2>

This document, the Enterprise Ethereum Alliance Enhanced BFT Specification,
defines enhancements to the BFT algorithm, including liveness and security.

  </section>

  <section id="sec-overview" class="informative">

  <h2>Overview</h2>

This section introduces the Enhanced BFT specification and provides a general
overview of the protocol.

    <section id="sec-terminology" class="informative">

    <h3>Terminology</h3>

This section outlines the terminology used to describe the Enhanced BFT
protocol.

  <dl>
    <dt><dfn data-lt="validator">Validators</dfn></dt>
	<dd>
Multiple nodes participating in the Enhanced BFT protocol to finalize blocks on
the chain.

    </dd>
	<dt><dfn data-lt="proposers">Proposer</dfn></dt>
	<dd>
A <a>validator</a> that proposes a block. Only one node acts as a proposer for
any given <a>round</a>.
    </dd>
	<dt><dfn data-lt="standard nodes|node|nodes">Standard node</dfn></dt>
	<dd>
A node that does not propose or validate blocks.
    </dd>
    <dt>Blockchain consensus protocol</dt>
    <dd>
Blockchains are the most widely-adopted implementations of <em>distributed
ledgers</em>, which are append-only databases of transactions that are
replicated across multiple participants and where the trust and responsibility
for maintaining the database is spread across all, or a subset of, the
participants.<br>

This is in contrast to traditional centralized systems where full trust is given
to a central authority responsible for maintaining the database. One issue with
this traditional approach is that the central authority has the power to alter
the database unilaterally. The decentralisation aspect of distributed ledger
technology makes it well suited in situations where the central authority is
either adding costs to the system or undermining trust in the system itself.

Blockchains implement distributed ledgers by batching transactions into blocks
and cryptographically linking each block to the previous one forming a chain of
blocks. Consensus protocols play a fundamental role in the blockchain technology
as they responsible for ensuring that the chain of blocks replicated amongst the
participants is consistent. The type of network and environment assumptions made
when designing a consensus protocol influence how the blockchain performs after
it is deployed in a real environment and network. Some of the key performance
metrics that are heavily influenced by consensus protocols are:
      <ul>
        <li>
Throughput. For example, the number of transactions per second.
        </li>
        <li>
Latency. That is, time taken from when a transaction is submitted to the system
to when the transaction is included in a block.
        </li>
        <li>
Robustness. That is, what type of attacks the protocol can withstand.
        </li>
      </ul>
    </dd>
    <dt>Ethereum smart contracts</dt>
    <dd>
Compared to Bitcoin, which was the first widely adopted blockchain and mainly
allows transferring values between participants, the Ethereum blockchain
specifies a Turing-complete language that can be used to build small distributed
programs, called <em>smart contracts</em>. Smart contracts are executed on a
sandboxed runtime on any participant on execution of transactions. The
availability of a Turing-complete language allows users to specify a custom set
of rules and behavior associated with any transaction referring a specific smart
contract.
    </dd>
    <dt>Byzantine fault tolerant (BFT)</dt>
    <dd>
Byzantine fault tolerant, or BFT, specifies the type of participant fault mode
that the consensus protocol can cope with. Specifically, BFT identifies a class
of consensus protocols that ensure blockchain consistency despite some of the
participants, referred to as Byzantine, being malicious and acting arbitrarily.
The term <dfn>Byzantine</dfn> is used to identify malicious nodes, and dates back
to the paper "The Byzantine Generals Problem" by Lamport et al. The Byzantine
failure mode is the strongest failure mode considered in the consensus protocol
literature. Another common, but weaker, failure mode is fail-stop failure mode,
which only considers participants that stop communicating, but never acting
maliciously.
    </dd>
    <dt>Poof of Authority (PoA)</dt>
    <dd>
Another way to classify consensus protocols is by the technique used to prevent
Sybil attacks. A Sybil attack is where a participant is able able to gain power
in the system by creating multiple pseudonymous identities. Typically, creating
a new digital identity that can be used to interact with a blockchain is
relatively cheap because it only requires generating a random private key and
the related public key, which can be done in a matter of seconds on any modern
personal computer.<br>

One of the most widely used and famous techniques for preventing Sybil attacks
is Proof of Work (PoW), which wasoriginally pioneered by Dwork et al., and
gained subsequent publicity by its employment in Bitcoin. PoW requires
participants to spend computing effort in solving a hard cryptographic puzzle
before being able to propose a block to be added to the blockchain.

Proof of Stake (PoS) is another well known technique where the right to propose
new blocks is given by the amount of stake owned.

In contrast, PoA prevents Sybil attacks by conferring the right to create new
blocks only to a defined set of identities.
    </dd>
    <dt>Consortium blockchains</dt>
    <dd>
Compared to permissionless, or public, blockchains, like Bitcoin or Ethereum,
where anybody can join the network and participate in the protocol, in
consortium blockchains permissioning exists, which enables only a set of
participants to propose new blocks and to participate in the consensus
protocol.<br>

PoA type consensus protocols, like Enhanced BFT, are well suited to this type of
permissioning. While not every participant can propose new blocks, some
consoritum blockchains allow any valid blockchain identity to read data from the
blockchain. Enhanced BFT also allows for this type of configuration.
    </dd>
    <dt>Immediate Finality</dt>
    <dd>
A transaction is deemed to be <em>final</em> after it is included in the
blockchain and it cannot be removed, except if the environment is compromised. A
compromise can occur, for example, if the number of Byzantine participants is
higher than the maximum number the protocol can withstand.<br>

Immediate finality means that as soon as a transaction is included in a block,
the protocol guarantees that the transaction will not be removed.

By comparison, the PoW consensus protocol in Bitcoin and Ethereum only
guarantees eventual probabilistic finality, where the deeper a transaction is in
the blockchain, the less probable that the transaction can be removed or have
its position changed. Casper FFG, the Ethereum 2.0 PoS consensus protocol,
provides eventual non-probabilistic finality, where transactions eventually
reach a state where they cannot be removed or have their position changed, but
this does not necessarily happen at every block.
    </dd>
    <dt>Robust in an eventually synchronous network</dt>
    <dd>
<em>Robustness</em> refers to two important properties that any blockchain
consensus protocol must provide:
      <ul>
        <li>
Persistence, which ensures consistency of the blockchain amongst all
participants.
        </li>
        <li>
<dfn>Liveness</dfn>, which ensures that transactions submitted to participants will
eventually be included in the blockchain.
        </ul>
      </ul>

An eventually synchronous network identifies a network model under which
robustness of the protocol can be assured. In literature, there are three main
network models that were considered, which differ on the assumptions made on
transmission latency:
      <ul>
        <li>
Synchronous networks. The maximum latency (the time required for a message to
reach its recipient) is bounded and known.
        </li>
        <li>
Asynchronous networks. The maximum latency is unknown and messages might never
be delivered.
        </li>
        <li>
Partially synchronous networks. This model lies in between synchronous and
asynchronous. Specifically, there are two possible definitions of partial
synchronous networks:
          <ul>
            <li>
Messages are guaranteed to be delivered, but the maximum latency is unknown. To
the best of our knowledge, no specific name is defined for this model.
            </li>
            <li>
Eventually synchronous networks where there exists a point in time, called
global stabilisation time (GST) after which the message delay is bounded by a
finite and constant value.
            </li>
          </ul>
        </li>
      </ul>

The model with the weakest assumptions is the asynchronous network model, followed
by the partially synchronous network model and then the synchronous network
model, in this order. Between the two definitions of partial synchronous
networks, eventual synchrony is the one with the weaker assumptions. As proved
by Fischer et al. [2] in 1985, no consensus protocol that aims to tolerate at
least one fail-stop participant is guaranteed to terminate in the model with the
weakest assumptions (asynchronous network model). This means that the liveness
property introduced above would be impaired in this model. There exist solutions
that operate in the asynchronous network model, but the termination is only
guaranteed probabilistically. The Enhanced BFT protocol is therefore robust in
the network model with the weakest assumptions coming after the asynchronous
network model.
    </dd>
    <dt>Dynamic validator set</dt>
    <dd>
Compared to classic (non-blockchain) consensus protocols where the set of
participants is known in advance and never changes, Enhanced BFT, like Clique,
allows participants to add and remove validators by a voting mechanism.<br>

Enhanced BFT builds on the IBFT consensus protocol and addresses the following
limitations of IBFT, as described by Saltini:
      <ul>
        <li>
Termination of IBFT is not guaranteed in an eventually synchronous network.
        </li>
        <li>
If the number of validators, $n$, is not exactly a multiple of 3 plus 1 (that
is, $\lfloor\frac{n-1}{3}\rfloor\neq{0}$), then one Byzantine node can remove or
change the position of a transaction that was already finalised.
        </li>
      </ul>

An obstacle facing enterprises when considering adopting the Ethereum technology
at scale is the lack of a well and standardised consortium consensus protocol.
As clear indication of this, the latest Enterprise Ethereum Alliance (EEA)
specifications fail to specify a consensus protocols to be used in the EEA
context.

This work aims to fill this gap by describing the Enhanced BFT protocol in a
form well suited for translation into actual implementation to enable
interoperability between multiple consortium Ethereum clients and therefore
promote the usage of the Ethereum technology within the enterprise world.
    </dd>
  </dl>
    </section>

    <section id="sec-protocol-overview" class="informative">

    <h3>Protocol Overview</h3>

The Enhanced BFT protocol consists of a series of messages exchanged by
<a>proposers</a> and <a>validators</a> using the gossip protocol to reach
consensus on block finalization. All messages in the protocol are signed by the
sender. The protocol finalizes one block at a time, starting from the block
after the <dfn>genesis block</dfn> (the first block of a blockchain). After a
block of <dfn>height</dfn> (the position of a block in the blockchain)
<code>h</code> is finalized, the protocol proceeds with the finalization of the
block with height <code>h + 1</code>.

Block finalization proceeds by <dfn data-lt="round">rounds</dfn>. The purpose of
each round is to reach agreement on which block should be added to the chain for
each specific <a>height</a>. For each round, one of the <a>validators</a> plays
the role of <a>proposer</a>. New rounds are started when the <a>validator</a>
suspects they will not reach agreement on the block to be added to the chain in
the current round.

For the first <a>round</a> for the current <a>height</a> (round 0) the
<a>proposer</a> sends a <a>Proposal message</a> to all <a>validators</a>.

When a <a>validator</a> receives a <a>Proposal message</a>, it sends a
<a>Prepare message</a> to all other <a>validators</a>. A <a>validator</a> is
said to be <dfn>prepared</dfn> for a specific <a>round</a>, <a>height</a>, and
<a>proposed block</a> if it has received <code>(QUORUM(NV)-1)</code>
<a>Prepare messages</a> where the hash of the <a>proposed block</a> matches the
hash of the <a>proposed block</a> included in the <a>Proposal message</a>
received previously.

When a <a>validator</a> is <a>prepared</a>, it sends a <a>Commit message</a> to
all other <a>validators</a>, including itself.

However, a <a>Byzantine</a> <a>proposer</a> might either never propose a valid
block or propose different blocks to different <a>validators</a>, impeding the
the protocol from reaching consensus on the next block to add to the blockchain.
To solve this <a>liveness</a> issue, every time a <a>validator</a> receives a
new valid block, it starts a new round timer. When the round timer for a
<a>validator</a> expires, the <a>validator</a> broadcasts a
<a>Round Change message</a> to all <a>validators</a>. The content of the
<code>preparedCertificate</code> field is empty if the <a>validator</a> is not
<a>prepared</a>, otherwise the <code>preparedCertificate</code> field contains
the set of <a>Proposal messages</a> and <a>Prepare messages</a> for the highest
round at which the <a>validator</a> is prepared for.

For example, if a <a>validator</a> prepared on proposed block <code>PB1</code>
at round 0, did not prepare on any block at round 2, prepared on proposed block
<code>PB2</code> at round 3, and did not prepare on any block at round 4, then
the <code>preparedCertificate</code> field included in the next
<a>Round Change message</a> includes the <a>Proposal messages</a> and
<a>Prepare messages</a> that caused <a>validator</a> to be prepared at round 3
on proposed block <code>PB2</code>. When the <a>proposer</a> for round
<code>r+1</code> receives <code>QUORUM(NV)</code> <a>Round Change messages</a>
for the same <code>r</code>+1 round and height <code>h</code>, it broadcasts a
<a>New Round message</a> to all <a>validators</a>. The <code>roundChange</code>
certificate contains the <code>QUORUM(NV)</code> <a>Round Change messages</a>
received and the <code>latestProposedBlock</code> field contains the
<a>Proposal message</a> for round <code>r+1</code>.

The <a>Proposal message</a> is determined in the following way. If the
<a>proposer</a> for round <code>r+1</code> has received at least one
<a>Round Change message</a> with a valid and non-empty
<code>preparedCertificate</code>, then the <a>Proposal message</a> contains the
<a>Proposal message</a> included in <code>preparedCertificate</code> with the
highest round number. Otherwise, the <a>Proposal message</a> is a
<a>Proposal message</a> signed by the <a>validator</a>for any valid block.

When a <a>validator</a> receives a <a>New Round message</a>, it verifies that the
<code>roundChangeCertificate</code> field contains <code>QUORUM(NV)</code>
valid <a>Round Change messages</a> and then verifies the <a>Proposal message</a>
included in the <a>New Round message</a> by performing a computation similar to
the one used by the sender of the <a>New Round message</a>. If no
<a>Round Change message</a> included in the <code>roundChangeCertificate</code>
includes a <code>prepareCertificate</code>, then any <a>Proposal message</a> for
a valid block included in the <a>New Round message</a> is accepted.

  <p>
If validation of the <a>New Round message</a> is successful, the <a>validator</a>
acts as if it has received the <a>Proposal message</a> from the <a>proposer</a>
and hence will broadcast a <a>Prepare message</a> as described above.
  </p>
  
    </section>


    <section id="sec-assumptions" class="informative">

    <h3>Assumptions</h3>

This section describes the assumptions made for the Enhanced BFT protocol.


    </section>

  </section>

  <section id="sec-message-structures">

  <h2>Message Structures</h2>

This section defines the structures of the BFT sub-protocol messages
communicated between Ethereum nodes.

All messages MUST be encoded using RLP encoding serialisation as specified in
[https://github.com/ethereum/wiki/wiki/RLP].

For any type of message, the signature corresponds to the hash over the message
using the validator private key:

<code>hashForMessageSignature(message) = KEC(concatenate(message.ID, RLP(message.payload)))</code>


    <section id="sec-proposal-message">

    <h3>Proposal Message</h3>

The block <a>proposer</a> MUST send the
<dfn data-lt="proposal messages">Proposal message</dfn> to all other
<a>validators</a> at the beginning of any round.

**Message content**

The Proposal message contains the following fields:

  - <code>0x00</code> DATA, x? bytes – The message ID for the Proposal message
type.
  - <code>payload</code> – A list containing each of the following:
  
    - <code>height</code> QUANTITY, 8 bytes – The <a>height</a> of the block
being proposed, as an integer.
    - <code>round</code> QUANTITY, 4 bytes – The <a>round</a> number, as an
integer.
    - <code>digest</code> DATA, 32 bytes – The Keccak hash of the proposed
block.
  - <code>signature</code> DATA, 65 bytes – The <a>signature</a> of the payload.
  - <code>proposedBlock</code> – The content of the proposed block in Ethereum
block format.

    </section>

    <section id="sec-prepare-message">

    <h3>Prepare Message</h3>

The <dfn data-lt="prepare messages">Prepare message</dfn> MUST be sent when a
<a>validator</a> that is not the designated block proposer for a round receives
a <a>Proposal message</a>.
  
**Message content**

The Prepare message contains the following fields:

  - <code>0x01</code> DATA, x? bytes – The message ID for the Prepare message
type.
  - <code>payload</code> – An array of the following:
  
    - <code>height</code> QUANTITY, 8 bytes – The <a>height</a> of the block
being prepared, as an integer.
    - <code>round</code> QUANTITY, 4 bytes – The <a>round</a> number, as an
integer.
    - <code>digest</code> DATA, 32 bytes – The <a>digest</a> of the prepared
block?
  - <code>signature</code> DATA, 65 bytes – The <a>signature</a> of the payload.

    </section>

    <section id="sec-commit-message">

    <h3>Commit Message</h3>

The <dfn data-lt="commit messages">Commit message</dfn> MUST be sent by a
<a>validator</a> when <em>enough</em> <a>Prepare messages</a> matching the
<a>Proposal</a> are sent by the designated <a>proposer</a>      mof the round are received.
  
**Message content**

The Commit message contains the following fields:

  - <code>0x02</code> DATA, x? bytes – The message ID for the Commit message
type.
  - <code>payload</code> – An array of one or more of the following:
  
    - <code>height</code> QUANTITY, 8 bytes – The <a>height</a> of the block
being prepared, as an integer.
    - <code>round</code> QUANTITY, 4 bytes – The <a>round</a> number, as an
integer.
    - <code>digest</code> DATA, 32 bytes – The <a>digest</a> of the prepared
block?
    - <code>commitSeal</code> DATA, 32 bytes – The signature of the
<a>validator</a> over the proposed block included in the <a>Proposal message</a>
received by the designated proposer of the round.
  - <code>signature</code> DATA, 65 bytes – The <a>signature</a> of the payload.

    </section>

    <section id="sec-round-change-message">

    <h3>Round Change Message</h3>

A <dfn data-lt="round change messages">Round Change message</dfn> MUST be sent
by a <a>validator</a> when they suspect no agreement on the block to be added to
the blockchain with the given height will be reached in this round.
  
**Message content**

The Round Change message contains the following fields:

  - <code>0x03</code> DATA, x? bytes – The message ID for the Round Change
message type.
  - <code>payload</code> – An array of one or more of the following:
  
    - <code>height</code> QUANTITY, 8 bytes – The <a>height</a> of the block for
which the <a>validator</a> is trying to reach agreement, as an integer.
    - <code>round</code> QUANTITY, 4 bytes – The <a>round</a> number to which
the <a>validator</a> intends to move to, as an integer.
    - <code>preparedCertificate</code> DATA – See below.
	  
  - <code>signature</code> DATA, 65 bytes – The <a>signature</a> of the
concatenation of the message ID and the payload.
  - <code>latestProposedBlock</code> DATA - <code>nil</code> or the content of
the latest prepared block in Ethereum block format. Should be <code>nil</code>
if <code>preparedCertificate</code> is <code>nil</code>.

The <code>preparedCertificate</code> might be <code>nil</code> or a list of: 

  - <code>signedPartOfProposalMessage</code> – The payload and signature copied
from the latest prepared <a>Proposal message</a>.
  - <code>signedPartOfPrepareMessages</code> – The list of payloads and
signatures copied from the latest prepared <a>Prepare messages</a>.

If <code>latestProposedBlock</code> is not <code>nil</code>, then the digest of
<code>signedPartOfProposalMessage</code> and all messages included in
<code>signedPartOfPrepareMessages</code> should match the Keccack hash of
<code>proposedBlock</code>.

    </section>

  </section>

  <section id="sec-block-header-modifications">

  <h2>Block Header Modifications</h2>

  </section>

  <section id="sec-pseudocode-protocol-description">

  <h2>Pseudocode Protocol Description</h2>
  <p>
The Enhanced BFT consensus protocol is described by pseudocode in Algorithms 2
and 3 where:
  </p>

  <ul>
    <li>
Each of the $\mathbf{upon}$ blocks in the pseudocode is assumed to be executed
atomically when the condition specified after the $\mathbf{upon}$ keyword is
satisfied.
    </li>
    <li>
All functions in $\mathtt{typewriter\;font}$ are defined in the remainder of
this section.
    </li>
    <li>
All functions in $italic\;font$ are defined in the pseudocode.
    </li>
    <li>
$\langle{m}\rangle_{\sigma_v}$ denotes a message $m$ signed by validator $v$.
    </li>
    <li>
$\mathtt{numOfReceived}{(m}\;\mathbf{with}\;{condition, v)}$ corresponds to
the number of messages $m$ received by validator $v$ for which $condition$
is verified.
    </li>
    <li>
$\mathtt{received}{(m}\;\mathbf{with}\;{condition, v)}$ is true if and only if
validator $v$ has received at least one message $m$ for which $condition$
is verified. That is,
$\mathtt{received}{(m}\;\mathbf{with}\;{condition, v)} \equiv \mathtt{numOfReceived}{(m}\;\mathbf{with}\;{condition, v)}\ge{1}$.
    </li>
    <li>
If $\mathbf{with}\;condition$ is omitted (that is,
$\mathtt{received}{(m, v)}$), then $\mathtt{received}$ is true if any message
matching $m$ was received by $v$.
    </li>
    <li>
The symbol $*$ denotes any value.
    </li>
    <li>
$\langle{m}\rangle\;\mathbf{from}\;{V}$ matches any message $m$ sent by a
validator included in the set $V$ .
    </li>
    <li>
$\mathtt{setsOfMesagesReceivedLike}{(m}\;\mathbf{with}\;{condition, v)}$
corresponds to all of the subsets including messages received that match $m$
for which $condition$ is verified.

For example, if validator $v$ receives the following messages:

- $m_1 \equiv \langle\mathsf{PREPARE}{, h, r, \mathtt{KEC(}{B}) \rangle_{\sigma_{v1}}}$
- $m_2 \equiv \langle\mathsf{PREPARE}{, h, r, \mathtt{KEC(}{B}) \rangle_{\sigma_{v2}}}$
- $m_3 \equiv \langle\mathsf{PREPARE}{, h, r, \mathtt{KEC(}{B}) \rangle_{\sigma_{v3}}}$
- $m_4 \equiv \langle\mathsf{PREPARE}{, h, r, \mathtt{KEC(}{B}) \rangle_{\sigma_{v4}}}$

where $v1$, $v2$, $v3$, and $v4$ are included in set $V$, then
$\mathtt{setsOfMessagesReceivedLike}{(\langle}\mathsf{PREPARE}, h, r, \mathtt{KEC(}{B}) \rangle_{\sigma_{sender}}\;\mathbf{with}\;sender\in{V,v)}$
corresponds to $\{\{\},\{m_1\},\{m_2\},\{m_3\},\{m_1,m_2\},\{m_1,m_3\},\{m_2,m_3\},\{m_1,m_2,m_3\}\}$.
    </li>
    <li>
$\mathtt{mesagesReceivedLike}{(m}$ $\mathbf{with}$ ${condition, v)}$ corresponds
to all the messages received matching ${m}$ for which ${condition}$ is verified.
In the context of the example presented above,
$\mathtt{messagesReceivedLike}{(\langle}\mathsf{PREPARE}, h, r, \mathtt{KEC(}{B}) \rangle_{\sigma_{sender}}\;\mathbf{with}\;sender\in{V,v)}$
corresponds to $\{m_1,m_2,m_3\}$.
    </li>
    <li>
$\mathtt{blockHeight}{(FB)}$ is defined as the height of the finalised block
${FB}$.
    </li>
    <li>
Each validator ${v}$ stores its local blockchain in ${chain_v}$.
    </li>
    <li>
${chain_v}{[n]}$ corresponds to the finalised block with height ${n}$, while ${chain_v}{[n:m]}$ corresponds to a sub-chain
including all of the finalised blocks from height ${n}$ to height ${m}$.
    </li>
    <li>
The blockchain height is defined as the height of the last finalised block added to the blockchain.
    </li>
    <li>
$\mathtt{validators}{(chain_v}{[0:h-1])}$ represents the set of authorised
validators for instance ${h}$ of the IBFT-block-finalization-protocol. The
definition of the $\mathtt{validators}{()}$ function is not presented here as it
is outside the scope of this work and does not have relevance to the results
presented here. For the same reason, we do not describe the protocol that can be
used to add or remove validators to or from the validator set of each instance
of the IBFT-block-finalisation-protocol.
    </li>
    <li>
$\mathtt{n}{(chain_v}{[0:h-1])}$ represents the number of validators for
instance ${h}$ of the IBFT-block-finalization-protocol. That is
$\mathtt{n}{(chain_v}{[0:h-1])}$ ${\equiv} \Vert \mathtt{n}{(chain_v}{[0:h-1]) \Vert}$.
    </li>
    <li>
$\mathtt{extractFinalisationProof}{(FB)}$ denotes the finalization proof
included in the finalized block ${FB}$;
    </li>
    <li>
$\mathtt{extractBlock}{(FB)}$ denotes the block included in the finalized block
${FB}$.
    </li>
    <li>
$\mathtt{extractRound}{(FB)}$ denotes the round number included in the finalized
block ${FB}$.
    </li>
    <li>
The function $\mathtt{isValidBlock}{(B,B_{parent})}$ is defined to be true if
and only if block ${B}$ is a valid Ethereum block with parent ${B_{parent}}$.
For the purpose of this work, we consider that
$\mathtt{isValidBlock}{(B,B_{parent})}$ only verifies the following fields of
the standard Ethereum header: <code>parentHash</code>, <code>stateRoot</code>,
<code>transactionsRoot</code>, <code>receiptsRoot</code>,
<code>logsBloom</code>, <code>number</code>, <code>gasLimit</code>, and
<code>gasUsed</code>. These fields are verified as specified in [7]. The IBFT
protocol implementation [5] actually verifies also the other fields but in a
different way than specified in [7]. We do not describe how these fields are
verified as this is out of the scope of this work and does not affect our
results.
    </li>
  </ul>

  <p>
The pseudocode in Algorithm 3 introduces the following macros and functions:
  </p>

- $n_{h,v}$ is the number of validators for the ${h}$-th instance of the
IBFT-block-finalization-protocol for validator ${v}$.
- $\mathtt{validators}_{h,v}$ is the validators for the $h$-th instance of the
IBFT-block-finalization-protocol for validator $v$.
- $\mathtt{proposer}_{h,v}{(r_{h,v})}$ is the proposer for round ${r_{h,v}}$ of
the $h$-th instance of the IBFT-block-finalization-protocol for validator $v$.
- $\mathtt{createNewProposedBlock}{(h, v)}$ represents the creation of a new
block with height $h$ by validator $v$.
- $\mathtt{timeoutForRoundZero}$ represents the round timer duration for round 0.
This is intended to be a parameter settable by the user.
    </li>
  </ul>

    <section id="sec-pseudocode">

    <h3>Pseudocode</h3>

<figure id="fig-algorithm1">
  <img src="./images/algorithm1_pseudocode.png" alt="Algorithm 1">
</figure>

<figure id="fig-algorithm2">
  <img src="./images/algorithm2_pseudocode.png" alt="Algorithm 2">
</figure>

<figure id="fig-algorithm3">
  <img src="./images/algorithm3_pseudocode.png" alt="Algorithm 3">
</figure>


    </section>

  </section>

  <section id="sec-additional-information" class="appendix">

  <h2>Additional Information</h2>

    <section id="sec-definitions">

    <h3>Terms defined in this specification</h3>

    <div class="inside">
      <ul class="respec-dfn-list">
        <li>
          <a href="#dfn-authorizedusers">
            authorizedUser<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-capability-protocols">
            capability protocols<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-client-requirements">
            Client requirements<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-consensus">
            Consensus<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-consensus-algorithms">
            consensus algorithm<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-consortium-networks">
            consortium network<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-dapp">
            ÐApps<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-devp2p">
            DEVp2p<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-enterprise-ethereum">
            Enterprise Ethereum<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-enterprise-ethereum-blockchains">
            Enterprise Ethereum blockchains<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-enterprise-ethereum-clients">
            Enterprise Ethereum client<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-ethereum-accounts">
            Ethereum account<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-ethereum-json-rpc-api">
            Ethereum JSON-RPC API<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-ens">
            Ethereum Name Service<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-evm">
            Ethereum Virtual Machine<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-final">
            Finality<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-formal-verification">
            Formal verification<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-gas">
            Gas<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-genesis-block">
            genesis block<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-group">
            Groups<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-hard-fork-block">
            hard fork block<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-hard-forks">
            hard fork<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-inter-chain-mediator">
            inter-chain mediators<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-integration-library">
            Integration libraries<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-mainnet">
            Ethereum MainNet<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-membergroups">
            memberGroups<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-metadata">
            Metadata<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-network">
            network<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-configurable">
            Network Configuration<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-node-list">
            node list<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-nodes">
            node<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-offchain-compute-scaling">
            Off-chain (layer 2 compute) scaling<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-onchain-layer-1-scaling">
            On-chain (layer 1) scaling<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-onchain-layer-2-scaling">
            On-chain (layer 2) scaling<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-onchain-privacy">
            On-chain privacy mechanisms<!---0.529120%-->
          </a>
        </li><li>
          <a href="#dfn-oracles">
            oracle<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-organizations">
            organization<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-payload-data">
            Payload data<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-performance">
            Performance<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-permissioning-decider">
            permissioning decider<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-permissions">
            Permissioning<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-precompiled-contracts">
            precompiled contract<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-privacy">
            Privacy<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-private-state">
            Private State<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-private-transaction-manager">
            private transaction manager<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-protocol-requirements">
            Protocol requirements<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-ethereum">
            Public Ethereum<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-restricted-private-transactions">
            Restricted private transactions<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-role">
            Roles<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-sidechains">
            sidechain<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-smart-contract-language">
            Smart contract languages<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-smart-contract">
            Smart contracts<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-private-transactions">
            private transaction<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-transactions">
            transaction<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-trusted-computing">
            Off-chain trusted computing<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-unrestricted-private-transactions">
            Unrestricted private transactions<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-users">
            User<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-wallet">
            Wallets<!---0.529120%-->
          </a>
        </li>
        <li>
          <a href="#dfn-zero-knowledge-proofs">
            zero-knowledge proof<!---0.529120%-->
          </a>
        </li><!---0.529120%-->
      </ul><!---0.529120%-->
    </div>
    </section>

    <section id="sec-summary-of-requirements">

    <h3>Summary of Requirements</h3>

This section summarizes all of the requirements in this Specification into one
section.

    </section>

    <section id="sec-acknowledgments">

    <h3>Acknowledgments</h3>

The EEA acknowledges and thanks the many people who contributed to the
development of this version of the specification. Please advise us of any errors
or omissions.


    </section>


  </section>

<script class='remove'>
async function loadSolidity() {    //this is the function you call in 'preProcess'
    const worker = await new Promise(resolve => {
      require(["core/worker"], ({ worker }) => resolve(worker));
    });
    const action = "highlight-load-lang";
    const langURL =
      "https://rawgit.com/pospi/highlightjs-solidity/master/solidity.js";
    const propName = "hljsDefineSolidity";
    const lang = "solidity";     // this is the class you use to identify the language
    worker.postMessage({ action, langURL, propName, lang });
    return new Promise(resolve => {
      worker.addEventListener("message", function listener({ data }) {
        const { action: responseAction, lang: responseLang } = data;
        if (responseAction === action && responseLang === lang) {
          worker.removeEventListener("message", listener);
          resolve();
        }
      });
    });
  }


function cleanUp () {
  document.querySelector('h2').removeChild(document.querySelector('h2').firstChild);
  document.head.removeChild(document.querySelectorAll('link[rel=stylesheet]')[1]);
  document.head.removeChild(document.querySelector('link[rel=canonical]'));

  document.querySelector('p.copyright').innerHTML="Copyright © 2018-2019 <a href='https://entethalliance.org/'>Enterprise Ethereum Alliance</a>."

  var linksList = document.querySelector('div.head > dl');
  linksList.removeChild(document.querySelectorAll('div.head dt')[5]);
  linksList.removeChild(document.querySelectorAll('div.head dt')[1]);
  linksList.removeChild(document.querySelectorAll('div.head dt')[0]);
  linksList.removeChild(document.querySelectorAll('div.head dd')[12]);
  linksList.removeChild(document.querySelectorAll('div.head dd')[11]);
  linksList.removeChild(document.querySelectorAll('div.head dd')[10]);
  linksList.removeChild(document.querySelectorAll('div.head dd')[9]);
  linksList.removeChild(document.querySelectorAll('div.head dd')[1]);
  linksList.removeChild(document.querySelectorAll('div.head dd')[0]);

  var theA = document.querySelector('[href=dummycontrib]');
  theA.outerHTML = theA.innerHTML;


  //
  // This is ugly but works unless ReSpec tracks a serious change to W3C boilerplate
  //

    var statusSection = document.querySelector('section#sotd');
    var statusPs = document.querySelectorAll('#sotd > p').length;
    statusSection.removeChild(document.querySelectorAll('#sotd > p')[(statusPs-1)]);
    statusSection.removeChild(document.querySelectorAll('#sotd > p')[(statusPs-2)]);
    statusSection.removeChild(document.querySelectorAll('#sotd > p')[(statusPs-3)]);
    statusSection.removeChild(document.querySelectorAll('#sotd > p')[(statusPs-5)]);
    statusSection.removeChild(document.querySelectorAll('#sotd > p')[0]);

}

var respecConfig = {
  preProcess: [loadSolidity],
  format: "markdown",
  specStatus: "ED",
  edDraftURI: "https://entethalliance.github.io/client-spec/spec.html",
  postProcess: [cleanUp],
  editors: [{
    name: "Robert Coote",
    company: "PegaSys",
    mailto: "robert.coote@consensys.net",
  },{
    name: "David Hyland-Wood",
    company: "PegaSys",
    mailto: "david.wood@consensys.net",
  },{
    name: "Grant Noble",
    company: "PegaSys",
    mailto: "grant.noble@consensys.net",
  },{
    name: "Roberto Saltini",
    company: "PegaSys",
    mailto: "roberto.saltini@consensys.net",
  }],
  github: "https://github.com/EntEthAlliance/enhanced-bft",
  shortName: "EnhancedBFT",
  copyrightStart: 2019,
  logos: [{
    src: './images/eea_logo.svg',
    href: "https://entethalliance.org",
    alt: " ",
    width: 180,
    height: 90,
    id: 'eea-logo',
  }],
  otherLinks: [{
    key: "Contributors to this version",
    data: [{
      value: "Firstname1 Lastname1 (Company1), \
          	  Firstname2 Lastname2 (Company2)",
      href:"dummycontrib"
    }]
  }],
  localBiblio: {
    "ABI": {
      title: "Contract ABI Specification",
      href: "https://solidity.readthedocs.io/en/develop/abi-spec.html",
      publisher: "Ethereum Foundation"
    },
    "Byzantine-Fault-Tolerant": {
      title: "Byzantine Fault Tolerant",
      href: "https://en.wikipedia.org/wiki/Byzantine_fault_tolerance"
    },
    "DEVp2p-Node-Discovery": {
      title: "Node Discovery Protocol",
      href: "https://github.com/ethereum/devp2p/blob/master/rlpx.md"
    },
    "DEVp2p-Wire-Protocol": {
      title: "ÐΞVp2p Wire Protocol",
      href: "https://github.com/ethereum/devp2p/blob/master/caps/eth.md"
    },
    "DIF": {
      title: "Decentralized Identity Foundation",
      href: "http://identity.foundation/"
    },
    "EEA-OC": {
      title: "EEA Off-Chain Trusted Compute Specification V0.5",
      href: "http://entethalliance.org/wp-content/uploads/2018/10/EEA_Off_Chain_Trusted_Compute_Specification_V0_5.pdf",
      publisher: "Enterprise Ethereum Alliance, Inc."
    },
    "EIP-225": {
      title: "Clique proof-of-authority consensus protocol",
      href: "https://eips.ethereum.org/EIPS/eip-225",
      publisher: "Ethereum Foundation"
    },
    "EIP-648": {
      title: "Easy Parallelizability",
      href: "https://github.com/ethereum/EIPs/issues/648",
      publisher: "Ethereum Foundation"
    },
    "EIP-650": {
      title: "Istanbul Byzantine Fault Tolerance",
      href: "https://github.com/ethereum/EIPs/issues/650",
      publisher: "Ethereum Foundation"
    },
    "EIP-1013": {
      title: "Hardfork Meta: Constantinople",
      href: "https://eips.ethereum.org/EIPS/eip-1013",
      publisher: "Ethereum Foundation"
    },
    "EIP-1352": {
      title: "Specify restricted address range for precompiles/system contracts",
      href: "https://eips.ethereum.org/EIPS/eip-1352",
      publisher: "Ethereum Foundation"
    },
    "EIPs": {
      title: "Ethereum Improvement Proposals",
      href: "https://eips.ethereum.org/",
      publisher: "Ethereum Foundation"
    },
    "enode": {
      title: "Ethereum enode URL format",
      href: "https://github.com/ethereum/wiki/wiki/enode-url-format",
      publisher: "Ethereum Foundation"
    },
    "ERC-20": {
      title: "Ethereum Improvement Proposal 20 - Standard Interface for Tokens",
      href: "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md",
      publisher: "Ethereum Foundation"
    },
    "ERC-223": {
      title: "Ethereum Improvement Proposal 223 - Token Standard",
      href: "https://github.com/ethereum/EIPs/issues/223",
      publisher: "Ethereum Foundation"
    },
    "ERC-621": {
      title: "Ethereum Improvement Proposal 621 - Token Standard Extension for Increasing & Decreasing Supply",
      href: "https://github.com/ethereum/EIPs/pull/621",
      publisher: "Ethereum Foundation"
    },
    "ERC-721": {
      title: "Ethereum Improvement Proposal 721 - Non-fungible Token Standard",
      href: "https://github.com/ethereum/eips/issues/721",
      publisher: "Ethereum Foundation"
    },
    "ERC-827": {
      title: "Ethereum Improvement Proposal 827 - Extension to ERC-20",
      href: "https://github.com/ethereum/EIPs/issues/827",
      publisher: "Ethereum Foundation"
    },
    "Ethereum": {
      title: "Ethereum Foundation",
      href: "https://www.ethereum.org/foundation"
    },
    "Ethereum-Foundation": {
      aliasOf: "Ethereum"
    },
    "Ethereum-Wire-Protocol": {
      title: "Ethereum Wire Protocol",
      href: "https://github.com/ethereum/wiki/wiki/Ethereum-Wire-Protocol"
    },
    "Ethereum-Yellow-Paper": {
      title: "Ethereum: A Secure Decentralized Generalized Transaction Ledger",
      href: "https://ethereum.github.io/yellowpaper/paper.pdf",
      publisher: "Dr. Gavin Wood"
    },
    "EVM-Opcodes": {
      title: "Ethereum Virtual Machine (EVM) Opcodes and Instruction Reference",
      href: "https://github.com/trailofbits/evm-opcodes"
    },
    "eWASM": {
      title: "Ethereum-flavored WebAssembly",
      href: "https://github.com/ewasm/design"
    },
    "GDPR": {
      title: "European Union General Data Protection Regulation",
      href: "https://eur-lex.europa.eu/legal-content/EN/TXT/?qid=1528874672298&uri=CELEX%3A32016R0679",
      publisher: "European Union"
    },
    "debug-traceTransaction":{
      title: "debug_traceTransaction",
      href: "https://github.com/ethereum/go-ethereum/wiki/Management-APIs"
    },
	"geth-repo":{
      title: "Go-Ethereum",
      href: "https://github.com/ethereum/go-ethereum/"
    },
	"implementation-code-in-Golang":{
      title: "implementation code in Golang",
      href: "https://github.com/ethereum/go-ethereum/blob/master/core/vm/contracts.go#L50-L360"
    },
    "IBFT-2.0": {
      title: "IBFT 2.0 Specification",
      href: "https://arxiv.org/abs/1901.07160",
      publisher: "PegaSys (ConsenSys)"
    },
    "JSON-RPC": {
      title: "JavaScript Object Notation - Remote Procedure Call",
      href: "http://www.jsonrpc.org/specification",
      publisher: "JSON-RPC Working Group"
    },
    "JSON-RPC-API": {
      title: "Ethereum JSON-RPC API",
      href: "https://github.com/ethereum/wiki/wiki/JSON-RPC",
      publisher: "Ethereum Foundation"
    },
    "JSON-RPC-API-v27e37ee": {
      title: "Ethereum JSON-RPC API",
      href: "https://github.com/ethereum/wiki/wiki/JSON-RPC/27e37ee31ca29565fd8542ced0814fefc37a94fb",
      publisher: "Ethereum Foundation"
    },
    "JSON-RPC-PUB-SUB": {
      title: "RPC PUB-SUB",
      href: "https://github.com/ethereum/go-ethereum/wiki/RPC-PUB-SUB",
      publisher: "Ethereum Foundation"
    },
    "Layer2-Scaling-Solutions": {
      title: "Making Sense of Ethereum's Layer 2 Scaling Solutions: State Channels, Plasma, and Truebit",
      href: "https://medium.com/l4-media/making-sense-of-ethereums-layer-2-scaling-solutions-state-channels-plasma-and-truebit-22cb40dcc2f4",
      publisher: "Josh Stark",
      date: "February 2018"
    },
    "LLL": {
      title: "LLL Introduction",
      href: "http://lll-docs.readthedocs.io/en/latest/lll_introduction.html",
      publisher: "Ben Edgington",
      date: "2017"
    },
    "Nethereum": {
      title: "Nethereum .NET Integration Library",
      href: "https://nethereum.com",
      publisher: "Nethereum Open Source Community"
    },
    "Plasma": {
      title: "Plasma: Scalable Autonomous Smart Contracts",
      href: "https://plasma.io/plasma.pdf",
      publisher: "Joseph Poon and Vitalik Buterin",
      date: "August 2017"
    },
    "PoET": {
      title: "Proof of Elapsed Time 1.0 Specification",
      href: "https://sawtooth.hyperledger.org/docs/core/releases/1.0/architecture/poet.html#",
      publisher: "Intel Corporation",
      date: "2015-2017"
    },
    "protocol-buffers": {
      title: "A language-neutral, platform-neutral extensible mechanism for serializing structured data",
      href: "https://developers.google.com/protocol-buffers/",
      publisher: "Google Developers"
    },
    "PSD2": {
      title: "European Union Personal Service Directive",
      href: "https://ec.europa.eu/info/law/payment-services-psd-2-directive-eu-2015-2366_en",
      publisher: "European Union"
    },
    "RAFT": {
      title: "Raft-based Consensus for Ethereum/Quorum",
      href: "https://github.com/jpmorganchase/quorum/blob/master/raft/doc.md",
      publisher: "J.P. Morgan"
    },
    "Remix": {
      title: "Ethereum Tools for the Web",
      href: "https://github.com/ethereum/remix",
      publisher: "Ethereum Foundation"
    },
    "RLP": {
      title: "Recursive Length Prefix",
      href: "https://github.com/ethereum/wiki/wiki/RLP",
      publisher: "Ethereum Foundation"
    },
    "sharding": {
      title: "Sharding FAQs",
      href: "https://github.com/ethereum/wiki/wiki/Sharding-FAQs",
      publisher: "Ethereum Foundation"
    },
    "Solidity": {
      title: "The Solidity Contract-Oriented Programming Language",
      href: "https://github.com/ethereum/solidity",
      publisher: "Ethereum Foundation"
    },
    "state-channels": {
      title: "Counterfactual: Generalized State Channels",
      href: "https://counterfactual.com/statechannels"
    },
    "Truffle": {
      title: "Ethereum Development Framework",
      href: "https://truffleframework.com/",
      publisher: "ConsenSys"
    },
    "web3j": {
      title: "web3j Lightweight Ethereum Java and Android Integration Library",
      href: "https://web3j.io",
      publisher: "Conor Svensson"
    },
    "web3.js": {
      title: "Ethereum JavaScript API",
      href: "https://github.com/ethereum/web3.js",
      publisher: "Ethereum Foundation"
    },
    "Whisper-protocol": {
      title: "Whisper",
      href: "https://github.com/ethereum/wiki/wiki/Whisper",
      publisher: "Ethereum Foundation"
    },
    "ZK-STARKS": {
      title: "Scalable, transparent, and post-quantum secure computational integrity",
      href: "https://eprint.iacr.org/2018/046.pdf",
      publisher: "Cryptology ePrint Archive",
      date: "2018-03-16"
    }
  }
};
</script>

</body>

</html>
